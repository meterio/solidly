{
  "language": "Solidity",
  "sources": {
    "contracts/base/core/GovernanceTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IERC20.sol\";\nimport \"../../lib/SafeERC20.sol\";\n\ncontract GovernanceTreasury {\n    using SafeERC20 for IERC20;\n\n    address public owner;\n    address public pendingOwner;\n\n    event Claimed(address receipent, address token, uint amount);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"Not owner\");\n        pendingOwner = _owner;\n    }\n\n    function acceptOwner() external {\n        require(msg.sender == pendingOwner, \"Not pending owner\");\n        owner = pendingOwner;\n    }\n\n    function claim(address[] memory tokens) external {\n        require(msg.sender == owner, \"Not owner\");\n        for (uint i; i < tokens.length; i++) {\n            address token = tokens[i];\n            uint balance = IERC20(token).balanceOf(address(this));\n            require(balance != 0, \"Zero balance\");\n            IERC20(token).safeTransfer(msg.sender, balance);\n            emit Claimed(msg.sender, token, balance);\n        }\n    }\n}\n"
    },
    "contracts/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.13;\n\nimport \"../interface/IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint value\n    ) internal {\n        uint newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/lib/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/BrokenToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../lib/SafeERC20.sol\";\n\ncontract BrokenToken {\n    function transfer(address _to, uint256 _value) external pure {}\n\n    function testBrokenTransfer() external {\n        SafeERC20.safeTransfer(IERC20(address(this)), address(this), 1);\n    }\n}\n"
    },
    "contracts/migrator/Migrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../interface/IPair.sol\";\nimport \"../interface/IRouter.sol\";\nimport \"../interface/IRouterOld.sol\";\nimport \"../interface/IFactory.sol\";\nimport \"../interface/IERC20.sol\";\nimport \"../interface/IUniswapV2Factory.sol\";\nimport \"../lib/SafeERC20.sol\";\n\ncontract Migrator {\n    using SafeERC20 for IERC20;\n\n    IUniswapV2Factory public oldFactory;\n    IRouter public router;\n\n    constructor(IUniswapV2Factory _oldFactory, IRouter _router) {\n        oldFactory = _oldFactory;\n        router = _router;\n    }\n\n    function getOldPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address)\n    {\n        return oldFactory.getPair(tokenA, tokenB);\n    }\n\n    function migrateWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        IPair pair = IPair(oldFactory.getPair(tokenA, tokenB));\n        pair.permit(msg.sender, address(this), liquidity, deadline, v, r, s);\n\n        migrate(\n            tokenA,\n            tokenB,\n            stable,\n            liquidity,\n            amountAMin,\n            amountBMin,\n            deadline\n        );\n    }\n\n    // msg.sender should have approved \"liquidity\" amount of LP token of \"tokenA\" and \"tokenB\"\n    function migrate(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        uint deadline\n    ) public {\n        require(deadline >= block.timestamp, \"Migrator: EXPIRED\");\n\n        // Remove liquidity from the old router with permit\n        (uint amountA, uint amountB) = removeLiquidity(\n            tokenA,\n            tokenB,\n            liquidity,\n            amountAMin,\n            amountBMin\n        );\n\n        // Add liquidity to the new router\n        (uint pooledAmountA, uint pooledAmountB) = addLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            amountA,\n            amountB\n        );\n\n        // Send remaining tokens to msg.sender\n        if (amountA > pooledAmountA) {\n            IERC20(tokenA).safeTransfer(msg.sender, amountA - pooledAmountA);\n        }\n        if (amountB > pooledAmountB) {\n            IERC20(tokenB).safeTransfer(msg.sender, amountB - pooledAmountB);\n        }\n    }\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin\n    ) public returns (uint amountA, uint amountB) {\n        IPair pair = IPair(oldFactory.getPair(tokenA, tokenB));\n        IERC20(address(pair)).safeTransferFrom(\n            msg.sender,\n            address(pair),\n            liquidity\n        );\n        (uint amount0, uint amount1) = pair.burn(address(this));\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n        require(amountA >= amountAMin, \"Migrator: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"Migrator: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired\n    ) internal returns (uint amountA, uint amountB) {\n        (amountA, amountB) = _addLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            amountADesired,\n            amountBDesired\n        );\n        address pair = router.pairFor(tokenA, tokenB, stable);\n        IERC20(tokenA).safeTransfer(pair, amountA);\n        IERC20(tokenB).safeTransfer(pair, amountB);\n        IPair(pair).mint(msg.sender);\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired\n    ) internal returns (uint amountA, uint amountB) {\n        // create the pair if it doesn\"t exist yet\n        IFactory factory = IFactory(router.factory());\n        if (factory.getPair(tokenA, tokenB, stable) == address(0)) {\n            factory.createPair(tokenA, tokenB, stable);\n        }\n        (uint reserveA, uint reserveB) = _getReserves(\n            router.factory(),\n            tokenA,\n            tokenB,\n            stable\n        );\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = quoteLiquidity(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= amountBDesired) {\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = quoteLiquidity(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= amountADesired);\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        public\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"ZERO_ADDRESS\");\n    }\n\n    // fetches and sorts the reserves for a pair\n    function _getReserves(\n        address factory,\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) internal view returns (uint reserveA, uint reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1, ) = IPair(\n            IFactory(factory).getPair(tokenA, tokenB, stable)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quoteLiquidity(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) public pure returns (uint amountB) {\n        require(amountA > 0, \"INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"INSUFFICIENT_LIQUIDITY\");\n        amountB = (amountA * (reserveB)) / reserveA;\n    }\n}\n"
    },
    "contracts/interface/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IPair {\n    // Structure to capture time period obervations every 30 minutes, used for local oracles\n    struct Observation {\n        uint timestamp;\n        uint reserve0Cumulative;\n        uint reserve1Cumulative;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        );\n\n    function getAmountOut(uint, address) external view returns (uint);\n\n    function claimFees() external returns (uint, uint);\n\n    function tokens() external view returns (address, address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function stable() external view returns (bool);\n\n    function metadata()\n        external\n        view\n        returns (\n            uint dec0,\n            uint dec1,\n            uint r0,\n            uint r1,\n            bool st,\n            address t0,\n            address t1\n        );\n}\n"
    },
    "contracts/interface/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IRouter {\n    struct Route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    function factory() external view returns (address);\n\n    function WMTR() external view returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    )\n        external\n        returns (\n            uint amountA,\n            uint amountB,\n            uint liquidity\n        );\n\n    function addLiquidityMTR(\n        address token,\n        bool stable,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        returns (\n            uint amountToken,\n            uint amountMTR,\n            uint liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityMTR(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountMTR);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityMTRWithPermit(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountMTR);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactMTRForTokens(\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactMTR(\n        uint amountOut,\n        uint amountInMax,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForMTR(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapMTRForExactTokens(\n        uint amountOut,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity\n    ) external view returns (uint amountA, uint amountB);\n\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired\n    )\n        external\n        view\n        returns (\n            uint amountA,\n            uint amountB,\n            uint liquidity\n        );\n\n    function pairFor(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (address pair);\n\n    function sortTokens(address tokenA, address tokenB)\n        external\n        pure\n        returns (address token0, address token1);\n\n    function quoteLiquidity(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) external pure returns (uint amountB);\n\n    function getAmountOut(\n        uint amountIn,\n        address tokenIn,\n        address tokenOut\n    ) external view returns (uint amount, bool stable);\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountIn, bool stable);\n\n    function getAmountsOut(uint amountIn, Route[] memory routes)\n        external\n        view\n        returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, Route[] memory routes)\n        external\n        view\n        returns (uint[] memory amounts);\n\n    function getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (uint reserveA, uint reserveB);\n\n    function getExactAmountOut(\n        uint amountIn,\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint amount);\n\n    function isPair(address pair) external view returns (bool);\n\n    function swapExactTokensForTokensSimple(\n        uint amountIn,\n        uint amountOutMin,\n        address tokenFrom,\n        address tokenTo,\n        bool stable,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForMTRSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactMTRForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external;\n\n    function removeLiquidityMTRWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountFTMMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountFTM);\n\n    function removeLiquidityMTRSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountFTMMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountFTM);\n}\n"
    },
    "contracts/interface/IRouterOld.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IRouterOld {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    )\n        external\n        returns (\n            uint amountA,\n            uint amountB,\n            uint liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        returns (\n            uint amountToken,\n            uint amountETH,\n            uint liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function sortTokens(address tokenA, address tokenB)\n        external\n        pure\n        returns (address token0, address token1);\n\n    function quote(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) external pure returns (uint amountB);\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountOut);\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountIn);\n\n    function getAmountsOut(uint amountIn, address[] calldata path)\n        external\n        view\n        returns (uint[] memory amounts);\n\n    function getAmountsIn(uint amountOut, address[] calldata path)\n        external\n        view\n        returns (uint[] memory amounts);\n}\n"
    },
    "contracts/interface/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IFactory {\n    function treasury() external view returns (address);\n\n    function isPair(address pair) external view returns (bool);\n\n    function getInitializable()\n        external\n        view\n        returns (\n            address,\n            address,\n            bool\n        );\n\n    function isPaused() external view returns (bool);\n\n    function pairCodeHash() external pure returns (bytes32);\n\n    function getPair(\n        address tokenA,\n        address token,\n        bool stable\n    ) external view returns (address);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external returns (address pair);\n}\n"
    },
    "contracts/interface/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/test/UniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./UniswapV2ERC20.sol\";\nimport \"./UQ112x112.sol\";\nimport \"./UniswapMath.sol\";\nimport \"../interface/IERC20.sol\";\n\ncontract UniswapV2Pair is UniswapV2ERC20 {\n    using SafeMath for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR =\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, \"UniswapV2: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint value\n    ) private {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(SELECTOR, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"UniswapV2: TRANSFER_FAILED\"\n        );\n    }\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(\n        address indexed sender,\n        uint amount0,\n        uint amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, \"UniswapV2: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint balance0,\n        uint balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        require(\n            balance0 <= type(uint112).max && balance1 <= type(uint112).max,\n            \"UniswapV2: OVERFLOW\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast +=\n                uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n                timeElapsed;\n            price1CumulativeLast +=\n                uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n                timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1)\n        private\n        returns (bool feeOn)\n    {\n        address feeTo = address(0);\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint rootK = UniswapMath.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = UniswapMath.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(5).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = UniswapMath.sqrt(amount0.mul(amount1)).sub(\n                MINIMUM_LIQUIDITY\n            );\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = UniswapMath.min(\n                amount0.mul(_totalSupply) / _reserve0,\n                amount1.mul(_totalSupply) / _reserve1\n            );\n        }\n        require(liquidity > 0, \"UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to)\n        external\n        lock\n        returns (uint amount0, uint amount1)\n    {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(\n            amount0 > 0 && amount1 > 0,\n            \"UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata\n    ) external lock {\n        require(\n            amount0Out > 0 || amount1Out > 0,\n            \"UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(\n            amount0Out < _reserve0 && amount1Out < _reserve1,\n            \"UniswapV2: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint balance0;\n        uint balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 && to != _token1, \"UniswapV2: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            //      if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out\n            ? balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out\n            ? balance1 - (_reserve1 - amount1Out)\n            : 0;\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"UniswapV2: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n            uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >=\n                    uint(_reserve0).mul(_reserve1).mul(1000**2),\n                \"UniswapV2: K\"\n            );\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(\n            _token0,\n            to,\n            IERC20(_token0).balanceOf(address(this)).sub(reserve0)\n        );\n        _safeTransfer(\n            _token1,\n            to,\n            IERC20(_token1).balanceOf(address(this)).sub(reserve1)\n        );\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n}\n"
    },
    "contracts/test/UniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./SafeMath.sol\";\n\ncontract UniswapV2ERC20 {\n    using SafeMath for uint;\n\n    string public constant name = \"Uniswap V2\";\n    string public constant symbol = \"UNI-V2\";\n    uint8 public constant decimals = 18;\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n    uint public chainId;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() {\n        uint _chainId;\n        assembly {\n            _chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                _chainId,\n                address(this)\n            )\n        );\n        chainId = _chainId;\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"UniswapV2: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"UniswapV2: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/test/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/test/UniswapMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n// a library for performing various math operations\n\nlibrary UniswapMath {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/test/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n"
    },
    "contracts/test/UniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./UniswapV2Pair.sol\";\n\ncontract UniswapV2Factory {\n    address public feeTo;\n    address public feeToSetter;\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint\n    );\n\n    constructor(address _feeToSetter) {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair)\n    {\n        require(tokenA != tokenB, \"UniswapV2: IDENTICAL_ADDRESSES\");\n        (address token0, address token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2: ZERO_ADDRESS\");\n        require(\n            getPair[token0][token1] == address(0),\n            \"UniswapV2: PAIR_EXISTS\"\n        );\n        // single check is sufficient\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        UniswapV2Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair;\n        // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(msg.sender == feeToSetter, \"UniswapV2: FORBIDDEN\");\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(msg.sender == feeToSetter, \"UniswapV2: FORBIDDEN\");\n        feeToSetter = _feeToSetter;\n    }\n}\n"
    },
    "contracts/test/StakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../interface/IERC20.sol\";\n\ncontract StakingRewards {\n    IERC20 public rewardsToken;\n    IERC20 public stakingToken;\n\n    uint public rewardRate = 100;\n    uint public lastUpdateTime;\n    uint public rewardPerTokenStored;\n    uint256 public periodFinish = 0;\n    uint256 public rewardsDuration = 7 days;\n\n    mapping(address => uint) public userRewardPerTokenPaid;\n    mapping(address => uint) public rewards;\n\n    uint private _totalSupply;\n    mapping(address => uint) public _balances;\n\n    constructor(address _stakingToken, address _rewardsToken) {\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IERC20(_rewardsToken);\n    }\n\n    function totalSupply() external view returns (uint) {\n        return _totalSupply;\n    }\n\n    function rewardPerToken() public view returns (uint) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\n                rewardRate *\n                1e18) / _totalSupply);\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function earned(address account) public view returns (uint) {\n        return\n            ((_balances[account] *\n                (rewardPerToken() - userRewardPerTokenPaid[account])) / 1e18) +\n            rewards[account];\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function stake(uint _amount) external updateReward(msg.sender) {\n        _totalSupply += _amount;\n        _balances[msg.sender] += _amount;\n        require(stakingToken.transferFrom(msg.sender, address(this), _amount));\n    }\n\n    function withdraw(uint _amount) external updateReward(msg.sender) {\n        _totalSupply -= _amount;\n        _balances[msg.sender] -= _amount;\n        require(stakingToken.transfer(msg.sender, _amount));\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        uint reward = rewards[msg.sender];\n        rewards[msg.sender] = 0;\n        require(rewardsToken.transfer(msg.sender, reward));\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        updateReward(address(0))\n    {\n        require(rewardsToken.transferFrom(msg.sender, address(this), reward));\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / (rewardsDuration);\n        }\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration;\n    }\n}\n"
    },
    "contracts/base/vote/VoltVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IVe.sol\";\nimport \"../../interface/IVoter.sol\";\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IERC721.sol\";\nimport \"../../interface/IGauge.sol\";\nimport \"../../interface/IFactory.sol\";\nimport \"../../interface/IPair.sol\";\nimport \"../../interface/IBribeFactory.sol\";\nimport \"../../interface/IGaugeFactory.sol\";\nimport \"../../interface/IMinter.sol\";\nimport \"../../interface/IBribe.sol\";\nimport \"../../interface/IMultiRewardsPool.sol\";\nimport \"../Reentrancy.sol\";\nimport \"../../lib/SafeERC20.sol\";\n\ncontract VoltVoter is IVoter, Reentrancy {\n    using SafeERC20 for IERC20;\n\n    /// @dev The ve token that governs these contracts\n    address public immutable override ve;\n    /// @dev VoltFactory\n    address public immutable factory;\n    address public immutable token;\n    address public immutable gaugeFactory;\n    address public immutable bribeFactory;\n    /// @dev Rewards are released over 7 days\n    uint internal constant DURATION = 7 days;\n    address public minter;\n\n    /// @dev Total voting weight\n    uint public totalWeight;\n\n    /// @dev All pools viable for incentives\n    address[] public pools;\n    /// @dev pool => gauge\n    mapping(address => address) public gauges;\n    /// @dev gauge => pool\n    mapping(address => address) public poolForGauge;\n    /// @dev gauge => bribe\n    mapping(address => address) public bribes;\n    /// @dev pool => weight\n    mapping(address => int256) public weights;\n    /// @dev nft => pool => votes\n    mapping(uint => mapping(address => int256)) public votes;\n    /// @dev nft => pools\n    mapping(uint => address[]) public poolVote;\n    /// @dev nft => total voting weight of user\n    mapping(uint => uint) public usedWeights;\n    mapping(address => bool) public isGauge;\n    mapping(address => bool) public isWhitelisted;\n\n    uint public index;\n    mapping(address => uint) public supplyIndex;\n    mapping(address => uint) public claimable;\n\n    event GaugeCreated(\n        address indexed gauge,\n        address creator,\n        address indexed bribe,\n        address indexed pool\n    );\n    event Voted(address indexed voter, uint tokenId, int256 weight);\n    event Abstained(uint tokenId, int256 weight);\n    event Deposit(\n        address indexed lp,\n        address indexed gauge,\n        uint tokenId,\n        uint amount\n    );\n    event Withdraw(\n        address indexed lp,\n        address indexed gauge,\n        uint tokenId,\n        uint amount\n    );\n    event NotifyReward(\n        address indexed sender,\n        address indexed reward,\n        uint amount\n    );\n    event DistributeReward(\n        address indexed sender,\n        address indexed gauge,\n        uint amount\n    );\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\n    event Whitelisted(address indexed whitelister, address indexed token);\n\n    constructor(\n        address _ve,\n        address _factory,\n        address _gaugeFactory,\n        address _bribeFactory\n    ) {\n        ve = _ve;\n        factory = _factory;\n        token = IVe(_ve).token();\n        gaugeFactory = _gaugeFactory;\n        bribeFactory = _bribeFactory;\n        minter = msg.sender;\n    }\n\n    function initialize(address[] memory _tokens, address _minter) external {\n        require(msg.sender == minter, \"!minter\");\n        for (uint i = 0; i < _tokens.length; i++) {\n            _whitelist(_tokens[i]);\n        }\n        minter = _minter;\n    }\n\n    /// @dev Amount of tokens required to be hold for whitelisting.\n    function listingFee() external view returns (uint) {\n        return _listingFee();\n    }\n\n    /// @dev 20% of circulation supply.\n    function _listingFee() internal view returns (uint) {\n        return (IERC20(token).totalSupply() - IERC20(ve).totalSupply()) / 5;\n    }\n\n    /// @dev Remove all votes for given tokenId.\n    function reset(uint _tokenId) external {\n        require(IVe(ve).isApprovedOrOwner(msg.sender, _tokenId), \"!owner\");\n        _reset(_tokenId);\n        IVe(ve).abstain(_tokenId);\n    }\n\n    function _reset(uint _tokenId) internal {\n        address[] storage _poolVote = poolVote[_tokenId];\n        uint _poolVoteCnt = _poolVote.length;\n        int256 _totalWeight = 0;\n\n        for (uint i = 0; i < _poolVoteCnt; i++) {\n            address _pool = _poolVote[i];\n            int256 _votes = votes[_tokenId][_pool];\n            _updateFor(gauges[_pool]);\n            weights[_pool] -= _votes;\n            votes[_tokenId][_pool] -= _votes;\n            if (_votes > 0) {\n                IBribe(bribes[gauges[_pool]])._withdraw(uint(_votes), _tokenId);\n                _totalWeight += _votes;\n            } else {\n                _totalWeight -= _votes;\n            }\n            emit Abstained(_tokenId, _votes);\n        }\n        totalWeight -= uint(_totalWeight);\n        usedWeights[_tokenId] = 0;\n        delete poolVote[_tokenId];\n    }\n\n    /// @dev Resubmit exist votes for given token. For internal purposes.\n    function poke(uint _tokenId) external {\n        address[] memory _poolVote = poolVote[_tokenId];\n        uint _poolCnt = _poolVote.length;\n        int256[] memory _weights = new int256[](_poolCnt);\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            _weights[i] = votes[_tokenId][_poolVote[i]];\n        }\n\n        _vote(_tokenId, _poolVote, _weights);\n    }\n\n    function _vote(\n        uint _tokenId,\n        address[] memory _poolVote,\n        int256[] memory _weights\n    ) internal {\n        _reset(_tokenId);\n        uint _poolCnt = _poolVote.length;\n        int256 _weight = int256(IVe(ve).balanceOfNFT(_tokenId));\n        int256 _totalVoteWeight = 0;\n        int256 _totalWeight = 0;\n        int256 _usedWeight = 0;\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            _totalVoteWeight += _weights[i] > 0 ? _weights[i] : -_weights[i];\n        }\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            address _pool = _poolVote[i];\n            address _gauge = gauges[_pool];\n\n            int256 _poolWeight = (_weights[i] * _weight) / _totalVoteWeight;\n            require(votes[_tokenId][_pool] == 0, \"duplicate pool\");\n            require(_poolWeight != 0, \"zero power\");\n            _updateFor(_gauge);\n\n            poolVote[_tokenId].push(_pool);\n\n            weights[_pool] += _poolWeight;\n            votes[_tokenId][_pool] += _poolWeight;\n            if (_poolWeight > 0) {\n                IBribe(bribes[_gauge])._deposit(uint(_poolWeight), _tokenId);\n            } else {\n                _poolWeight = -_poolWeight;\n            }\n            _usedWeight += _poolWeight;\n            _totalWeight += _poolWeight;\n            emit Voted(msg.sender, _tokenId, _poolWeight);\n        }\n        if (_usedWeight > 0) IVe(ve).voting(_tokenId);\n        totalWeight += uint(_totalWeight);\n        usedWeights[_tokenId] = uint(_usedWeight);\n    }\n\n    /// @dev Vote for given pools using a vote power of given tokenId. Reset previous votes.\n    function vote(\n        uint tokenId,\n        address[] calldata _poolVote,\n        int256[] calldata _weights\n    ) external {\n        require(IVe(ve).isApprovedOrOwner(msg.sender, tokenId), \"!owner\");\n        require(_poolVote.length == _weights.length, \"!arrays\");\n        _vote(tokenId, _poolVote, _weights);\n    }\n\n    /// @dev Add token to whitelist. Only pools with whitelisted tokens can be added to gauge.\n    function whitelist(address _token, uint _tokenId) external {\n        require(_tokenId > 0, \"!token\");\n        require(msg.sender == IERC721(ve).ownerOf(_tokenId), \"!owner\");\n        require(IVe(ve).balanceOfNFT(_tokenId) > _listingFee(), \"!power\");\n        _whitelist(_token);\n    }\n\n    function _whitelist(address _token) internal {\n        require(!isWhitelisted[_token], \"already whitelisted\");\n        isWhitelisted[_token] = true;\n        emit Whitelisted(msg.sender, _token);\n    }\n\n    /// @dev Add a token to a gauge/bribe as possible reward.\n    function registerRewardToken(\n        address _token,\n        address _gaugeOrBribe,\n        uint _tokenId\n    ) external {\n        require(_tokenId > 0, \"!token\");\n        require(msg.sender == IERC721(ve).ownerOf(_tokenId), \"!owner\");\n        require(IVe(ve).balanceOfNFT(_tokenId) > _listingFee(), \"!power\");\n        IMultiRewardsPool(_gaugeOrBribe).registerRewardToken(_token);\n    }\n\n    /// @dev Remove a token from a gauge/bribe allowed rewards list.\n    function removeRewardToken(\n        address _token,\n        address _gaugeOrBribe,\n        uint _tokenId\n    ) external {\n        require(_tokenId > 0, \"!token\");\n        require(msg.sender == IERC721(ve).ownerOf(_tokenId), \"!owner\");\n        require(IVe(ve).balanceOfNFT(_tokenId) > _listingFee(), \"!power\");\n        IMultiRewardsPool(_gaugeOrBribe).removeRewardToken(_token);\n    }\n\n    /// @dev Create gauge for given pool. Only for a pool with whitelisted tokens.\n    function createGauge(address _pool) external returns (address) {\n        require(gauges[_pool] == address(0x0), \"exists\");\n        require(IFactory(factory).isPair(_pool), \"!pool\");\n        (address tokenA, address tokenB) = IPair(_pool).tokens();\n        require(isWhitelisted[tokenA] && isWhitelisted[tokenB], \"!whitelisted\");\n\n        address[] memory allowedRewards = new address[](3);\n        allowedRewards[0] = tokenA;\n        allowedRewards[1] = tokenB;\n        if (token != tokenA && token != tokenB) {\n            allowedRewards[2] = token;\n        }\n\n        address _bribe = IBribeFactory(bribeFactory).createBribe(\n            allowedRewards\n        );\n        address _gauge = IGaugeFactory(gaugeFactory).createGauge(\n            _pool,\n            _bribe,\n            ve,\n            allowedRewards\n        );\n        IERC20(token).safeIncreaseAllowance(_gauge, type(uint).max);\n        bribes[_gauge] = _bribe;\n        gauges[_pool] = _gauge;\n        poolForGauge[_gauge] = _pool;\n        isGauge[_gauge] = true;\n        _updateFor(_gauge);\n        pools.push(_pool);\n        emit GaugeCreated(_gauge, msg.sender, _bribe, _pool);\n        return _gauge;\n    }\n\n    /// @dev A gauge should be able to attach a token for preventing transfers/withdraws.\n    function attachTokenToGauge(uint tokenId, address account)\n        external\n        override\n    {\n        require(isGauge[msg.sender], \"!gauge\");\n        if (tokenId > 0) {\n            IVe(ve).attachToken(tokenId);\n        }\n        emit Attach(account, msg.sender, tokenId);\n    }\n\n    /// @dev Emit deposit event for easily handling external actions.\n    function emitDeposit(\n        uint tokenId,\n        address account,\n        uint amount\n    ) external override {\n        require(isGauge[msg.sender], \"!gauge\");\n        emit Deposit(account, msg.sender, tokenId, amount);\n    }\n\n    /// @dev Detach given token.\n    function detachTokenFromGauge(uint tokenId, address account)\n        external\n        override\n    {\n        require(isGauge[msg.sender], \"!gauge\");\n        if (tokenId > 0) {\n            IVe(ve).detachToken(tokenId);\n        }\n        emit Detach(account, msg.sender, tokenId);\n    }\n\n    /// @dev Emit withdraw event for easily handling external actions.\n    function emitWithdraw(\n        uint tokenId,\n        address account,\n        uint amount\n    ) external override {\n        require(isGauge[msg.sender], \"!gauge\");\n        emit Withdraw(account, msg.sender, tokenId, amount);\n    }\n\n    /// @dev Length of pools\n    function poolsLength() external view returns (uint) {\n        return pools.length;\n    }\n\n    /// @dev Add rewards to this contract. Usually it is VoltMinter.\n    function notifyRewardAmount(uint amount) external override {\n        require(amount != 0, \"zero amount\");\n        uint _totalWeight = totalWeight;\n        // without votes rewards can not be added\n        require(_totalWeight != 0, \"!weights\");\n        // transfer the distro in\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        // 1e18 adjustment is removed during claim\n        uint _ratio = (amount * 1e18) / _totalWeight;\n        if (_ratio > 0) {\n            index += _ratio;\n        }\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    /// @dev Update given gauges.\n    function updateFor(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            _updateFor(_gauges[i]);\n        }\n    }\n\n    /// @dev Update gauges by indexes in a range.\n    function updateForRange(uint start, uint end) public {\n        for (uint i = start; i < end; i++) {\n            _updateFor(gauges[pools[i]]);\n        }\n    }\n\n    /// @dev Update all gauges.\n    function updateAll() external {\n        updateForRange(0, pools.length);\n    }\n\n    /// @dev Update reward info for given gauge.\n    function updateGauge(address _gauge) external {\n        _updateFor(_gauge);\n    }\n\n    function _updateFor(address _gauge) internal {\n        address _pool = poolForGauge[_gauge];\n        int256 _supplied = weights[_pool];\n        if (_supplied > 0) {\n            uint _supplyIndex = supplyIndex[_gauge];\n            // get global index for accumulated distro\n            uint _index = index;\n            // update _gauge current position to global position\n            supplyIndex[_gauge] = _index;\n            // see if there is any difference that need to be accrued\n            uint _delta = _index - _supplyIndex;\n            if (_delta > 0) {\n                // add accrued difference for each supplied token\n                uint _share = (uint(_supplied) * _delta) / 1e18;\n                claimable[_gauge] += _share;\n            }\n        } else {\n            // new users are set to the default global state\n            supplyIndex[_gauge] = index;\n        }\n    }\n\n    /// @dev Batch claim rewards from given gauges.\n    function claimRewards(address[] memory _gauges, address[][] memory _tokens)\n        external\n    {\n        for (uint i = 0; i < _gauges.length; i++) {\n            IGauge(_gauges[i]).getReward(msg.sender, _tokens[i]);\n        }\n    }\n\n    /// @dev Batch claim rewards from given bribe contracts for given tokenId.\n    function claimBribes(\n        address[] memory _bribes,\n        address[][] memory _tokens,\n        uint _tokenId\n    ) external {\n        require(IVe(ve).isApprovedOrOwner(msg.sender, _tokenId), \"!owner\");\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\n        }\n    }\n\n    /// @dev Claim fees from given bribes.\n    function claimFees(\n        address[] memory _bribes,\n        address[][] memory _tokens,\n        uint _tokenId\n    ) external {\n        require(IVe(ve).isApprovedOrOwner(msg.sender, _tokenId), \"!owner\");\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\n        }\n    }\n\n    /// @dev Move fees from deposited pools to bribes for given gauges.\n    function distributeFees(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            IGauge(_gauges[i]).claimFees();\n        }\n    }\n\n    /// @dev Get emission from minter and notify rewards for given gauge.\n    function distribute(address _gauge) external override {\n        _distribute(_gauge);\n    }\n\n    function _distribute(address _gauge) internal lock {\n        IMinter(minter).updatePeriod();\n        _updateFor(_gauge);\n        uint _claimable = claimable[_gauge];\n        if (\n            _claimable > IMultiRewardsPool(_gauge).left(token) &&\n            _claimable / DURATION > 0\n        ) {\n            claimable[_gauge] = 0;\n            IGauge(_gauge).notifyRewardAmount(token, _claimable);\n            emit DistributeReward(msg.sender, _gauge, _claimable);\n        }\n    }\n\n    /// @dev Distribute rewards for all pools.\n    function distributeAll() external {\n        uint length = pools.length;\n        for (uint x; x < length; x++) {\n            _distribute(gauges[pools[x]]);\n        }\n    }\n\n    function distributeForPoolsInRange(uint start, uint finish) external {\n        for (uint x = start; x < finish; x++) {\n            _distribute(gauges[pools[x]]);\n        }\n    }\n\n    function distributeForGauges(address[] memory _gauges) external {\n        for (uint x = 0; x < _gauges.length; x++) {\n            _distribute(_gauges[x]);\n        }\n    }\n}\n"
    },
    "contracts/interface/IVe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IVe {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME,\n        MERGE_TYPE\n    }\n\n    struct Point {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint ts;\n        uint blk; // block\n    }\n    /* We cannot really do block numbers per se b/c slope is per time, not per block\n     * and per block could be fairly bad b/c Ethereum changes blocktimes.\n     * What we can do is to extrapolate ***At functions */\n\n    struct LockedBalance {\n        int128 amount;\n        uint end;\n    }\n\n    function token() external view returns (address);\n\n    function balanceOfNFT(uint) external view returns (uint);\n\n    function isApprovedOrOwner(address, uint) external view returns (bool);\n\n    function createLockFor(\n        uint,\n        uint,\n        address\n    ) external returns (uint);\n\n    function userPointEpoch(uint tokenId) external view returns (uint);\n\n    function epoch() external view returns (uint);\n\n    function userPointHistory(uint tokenId, uint loc)\n        external\n        view\n        returns (Point memory);\n\n    function pointHistory(uint loc) external view returns (Point memory);\n\n    function checkpoint() external;\n\n    function depositFor(uint tokenId, uint value) external;\n\n    function attachToken(uint tokenId) external;\n\n    function detachToken(uint tokenId) external;\n\n    function voting(uint tokenId) external;\n\n    function abstain(uint tokenId) external;\n}\n"
    },
    "contracts/interface/IVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IVoter {\n    function ve() external view returns (address);\n\n    function attachTokenToGauge(uint _tokenId, address account) external;\n\n    function detachTokenFromGauge(uint _tokenId, address account) external;\n\n    function emitDeposit(\n        uint _tokenId,\n        address account,\n        uint amount\n    ) external;\n\n    function emitWithdraw(\n        uint _tokenId,\n        address account,\n        uint amount\n    ) external;\n\n    function distribute(address _gauge) external;\n\n    function notifyRewardAmount(uint amount) external;\n}\n"
    },
    "contracts/interface/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interface/IGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IGauge {\n    function notifyRewardAmount(address token, uint amount) external;\n\n    function getReward(address account, address[] memory tokens) external;\n\n    function claimFees() external returns (uint claimed0, uint claimed1);\n}\n"
    },
    "contracts/interface/IBribeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IBribeFactory {\n    function createBribe(address[] memory _allowedRewardTokens)\n        external\n        returns (address);\n}\n"
    },
    "contracts/interface/IGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IGaugeFactory {\n    function createGauge(\n        address _pool,\n        address _bribe,\n        address _ve,\n        address[] memory _allowedRewardTokens\n    ) external returns (address);\n\n    function createGaugeSingle(\n        address _pool,\n        address _bribe,\n        address _ve,\n        address _voter,\n        address[] memory _allowedRewardTokens\n    ) external returns (address);\n}\n"
    },
    "contracts/interface/IMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IMinter {\n    function updatePeriod() external returns (uint);\n}\n"
    },
    "contracts/interface/IBribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IBribe {\n    function notifyRewardAmount(address token, uint amount) external;\n\n    function _deposit(uint amount, uint tokenId) external;\n\n    function _withdraw(uint amount, uint tokenId) external;\n\n    function getRewardForOwner(uint tokenId, address[] memory tokens) external;\n}\n"
    },
    "contracts/interface/IMultiRewardsPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IMultiRewardsPool {\n    function underlying() external view returns (address);\n\n    function derivedSupply() external view returns (uint);\n\n    function derivedBalances(address account) external view returns (uint);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function rewardTokens(uint id) external view returns (address);\n\n    function isRewardToken(address token) external view returns (bool);\n\n    function rewardTokensLength() external view returns (uint);\n\n    function derivedBalance(address account) external view returns (uint);\n\n    function left(address token) external view returns (uint);\n\n    function earned(address token, address account)\n        external\n        view\n        returns (uint);\n\n    function registerRewardToken(address token) external;\n\n    function removeRewardToken(address token) external;\n}\n"
    },
    "contracts/base/Reentrancy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nabstract contract Reentrancy {\n    /// @dev simple re-entrancy check\n    uint internal _unlocked = 1;\n\n    modifier lock() {\n        require(_unlocked == 1, \"Reentrant call\");\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n}\n"
    },
    "contracts/interface/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/base/vote/Ve.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../lib/Base64.sol\";\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IERC721.sol\";\nimport \"../../interface/IERC721Metadata.sol\";\nimport \"../../interface/IVe.sol\";\nimport \"../../interface/IERC721Receiver.sol\";\nimport \"../../interface/IController.sol\";\nimport \"../Reentrancy.sol\";\nimport \"../../lib/SafeERC20.sol\";\nimport \"../../lib/Math.sol\";\n\ncontract Ve is IERC721, IERC721Metadata, IVe, Reentrancy {\n    using SafeERC20 for IERC20;\n\n    uint internal constant WEEK = 1 weeks;\n    uint internal constant MAX_TIME = 4 * 365 * 86400;\n    int128 internal constant I_MAX_TIME = 4 * 365 * 86400;\n    uint internal constant MULTIPLIER = 1 ether;\n\n    address public immutable override token;\n    uint public supply;\n    mapping(uint => LockedBalance) public locked;\n\n    mapping(uint => uint) public ownershipChange;\n\n    uint public override epoch;\n    /// @dev epoch -> unsigned point\n    mapping(uint => Point) internal _pointHistory;\n    /// @dev user -> Point[userEpoch]\n    mapping(uint => Point[1000000000]) internal _userPointHistory;\n\n    mapping(uint => uint) public override userPointEpoch;\n    mapping(uint => int128) public slopeChanges; // time -> signed slope change\n\n    mapping(uint => uint) public attachments;\n    mapping(uint => bool) public voted;\n    address public controller;\n\n    string public constant override name = \"veVOLT\";\n    string public constant override symbol = \"veVOLT\";\n    string public constant version = \"1.0.0\";\n    uint8 public constant decimals = 18;\n\n    /// @dev Current count of token\n    uint internal tokenId;\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint => address) internal idToOwner;\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint => address) internal idToApprovals;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint) internal ownerToNFTokenCount;\n\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint => uint)) internal ownerToNFTokenIdList;\n\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint => uint) internal tokenToOwnerIndex;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal supportedInterfaces;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    event Deposit(\n        address indexed provider,\n        uint tokenId,\n        uint value,\n        uint indexed locktime,\n        DepositType depositType,\n        uint ts\n    );\n    event Withdraw(address indexed provider, uint tokenId, uint value, uint ts);\n    event Supply(uint prevSupply, uint supply);\n\n    /// @notice Contract constructor\n    /// @param token_ `ERC20CRV` token address\n    constructor(address token_, address controller_) {\n        token = token_;\n        controller = controller_;\n        _pointHistory[0].blk = block.number;\n        _pointHistory[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n\n        // mint-ish\n        emit Transfer(address(0), address(this), tokenId);\n        // burn-ish\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n    function _voter() internal view returns (address) {\n        return IController(controller).voter();\n    }\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function supportsInterface(bytes4 _interfaceID)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return supportedInterfaces[_interfaceID];\n    }\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function getLastUserSlope(uint _tokenId) external view returns (int128) {\n        uint uEpoch = userPointEpoch[_tokenId];\n        return _userPointHistory[_tokenId][uEpoch].slope;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function userPointHistoryTs(uint _tokenId, uint _idx)\n        external\n        view\n        returns (uint)\n    {\n        return _userPointHistory[_tokenId][_idx].ts;\n    }\n\n    /// @notice Get timestamp when `_tokenId`'s lock finishes\n    /// @param _tokenId User NFT\n    /// @return Epoch time of the lock end\n    function lockedEnd(uint _tokenId) external view returns (uint) {\n        return locked[_tokenId].end;\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _balance(address _owner) internal view returns (uint) {\n        return ownerToNFTokenCount[_owner];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function balanceOf(address _owner) external view override returns (uint) {\n        return _balance(_owner);\n    }\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function ownerOf(uint _tokenId) public view override returns (address) {\n        return idToOwner[_tokenId];\n    }\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function getApproved(uint _tokenId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return idToApprovals[_tokenId];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function isApprovedForAll(address _owner, address _operator)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return (ownerToOperators[_owner])[_operator];\n    }\n\n    /// @dev  Get token by index\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex)\n        external\n        view\n        returns (uint)\n    {\n        return ownerToNFTokenIdList[_owner][_tokenIndex];\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\n    function _isApprovedOrOwner(address _spender, uint _tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        address owner = idToOwner[_tokenId];\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    function isApprovedOrOwner(address _spender, uint _tokenId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _isApprovedOrOwner(_spender, _tokenId);\n    }\n\n    /// @dev Add a NFT to an index mapping to a given address\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _addTokenToOwnerList(address _to, uint _tokenId) internal {\n        uint currentCount = _balance(_to);\n\n        ownerToNFTokenIdList[_to][currentCount] = _tokenId;\n        tokenToOwnerIndex[_tokenId] = currentCount;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\n        // Delete\n        uint currentCount = _balance(_from) - 1;\n        uint currentIndex = tokenToOwnerIndex[_tokenId];\n\n        if (currentCount == currentIndex) {\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint lastTokenId = ownerToNFTokenIdList[_from][currentCount];\n\n            // Add\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = currentIndex;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][currentCount] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _addTokenTo(address _to, uint _tokenId) internal {\n        // assume always call on new tokenId or after _removeTokenFrom() call\n        // Change the owner\n        idToOwner[_tokenId] = _to;\n        // Update owner token index tracking\n        _addTokenToOwnerList(_to, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_to] += 1;\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\n        require(idToOwner[_tokenId] == _from, \"!owner remove\");\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_from] -= 1;\n    }\n\n    /// @dev Execute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        address _sender\n    ) internal {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n        require(_isApprovedOrOwner(_sender, _tokenId), \"!owner sender\");\n        require(_to != address(0), \"dst is zero\");\n        // from address will be checked in _removeTokenFrom()\n\n        if (idToApprovals[_tokenId] != address(0)) {\n            // Reset approvals\n            idToApprovals[_tokenId] = address(0);\n        }\n        _removeTokenFrom(_from, _tokenId);\n        _addTokenTo(_to, _tokenId);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        ownershipChange[_tokenId] = block.number;\n        // Log the transfer\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /* TRANSFER FUNCTIONS */\n    /// @dev Throws unless `msg.sender` is the current owner,\n    ///      an authorized operator, or the approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n    ///        they maybe be permanently lost.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) external override {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        bytes memory _data\n    ) public override {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n\n        if (_isContract(_to)) {\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\n            try\n                IERC721Receiver(_to).onERC721Received(\n                    msg.sender,\n                    _from,\n                    _tokenId,\n                    _data\n                )\n            returns (bytes4) {} catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) external override {\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n    /// @param _approved Address to be approved for the given NFT ID.\n    /// @param _tokenId ID of the token to be approved.\n    function approve(address _approved, uint _tokenId) public override {\n        address owner = idToOwner[_tokenId];\n        // Throws if `_tokenId` is not a valid NFT\n        require(owner != address(0), \"invalid id\");\n        // Throws if `_approved` is the current owner\n        require(_approved != owner, \"self approve\");\n        // Check requirements\n        bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n        require(senderIsOwner || senderIsApprovedForAll, \"!owner\");\n        // Set the approval\n        idToApprovals[_tokenId] = _approved;\n        emit Approval(owner, _approved, _tokenId);\n    }\n\n    /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n    /// @notice This works even if sender doesn't own any tokens at the time.\n    /// @param _operator Address to add to the set of authorized operators.\n    /// @param _approved True if the operators is approved, false to revoke approval.\n    function setApprovalForAll(address _operator, bool _approved)\n        external\n        override\n    {\n        // Throws if `_operator` is the `msg.sender`\n        require(_operator != msg.sender, \"operator is sender\");\n        ownerToOperators[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _mint(address _to, uint _tokenId) internal returns (bool) {\n        // Throws if `_to` is zero address\n        require(_to != address(0), \"zero dst\");\n        // Add NFT. Throws if `_tokenId` is owned by someone\n        _addTokenTo(_to, _tokenId);\n        emit Transfer(address(0), _to, _tokenId);\n        return true;\n    }\n\n    /// @notice Record global and per-user data to checkpoint\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\n    /// @param oldLocked Pevious locked amount / end lock time for the user\n    /// @param newLocked New locked amount / end lock time for the user\n    function _checkpoint(\n        uint _tokenId,\n        LockedBalance memory oldLocked,\n        LockedBalance memory newLocked\n    ) internal {\n        Point memory uOld;\n        Point memory uNew;\n        int128 oldDSlope = 0;\n        int128 newDSlope = 0;\n        uint _epoch = epoch;\n\n        if (_tokenId != 0) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (oldLocked.end > block.timestamp && oldLocked.amount > 0) {\n                uOld.slope = oldLocked.amount / I_MAX_TIME;\n                uOld.bias =\n                    uOld.slope *\n                    int128(int256(oldLocked.end - block.timestamp));\n            }\n            if (newLocked.end > block.timestamp && newLocked.amount > 0) {\n                uNew.slope = newLocked.amount / I_MAX_TIME;\n                uNew.bias =\n                    uNew.slope *\n                    int128(int256(newLocked.end - block.timestamp));\n            }\n\n            // Read values of scheduled changes in the slope\n            // oldLocked.end can be in the past and in the future\n            // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldDSlope = slopeChanges[oldLocked.end];\n            if (newLocked.end != 0) {\n                if (newLocked.end == oldLocked.end) {\n                    newDSlope = oldDSlope;\n                } else {\n                    newDSlope = slopeChanges[newLocked.end];\n                }\n            }\n        }\n\n        Point memory lastPoint = Point({\n            bias: 0,\n            slope: 0,\n            ts: block.timestamp,\n            blk: block.number\n        });\n        if (_epoch > 0) {\n            lastPoint = _pointHistory[_epoch];\n        }\n        uint lastCheckpoint = lastPoint.ts;\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initialLastPoint = lastPoint;\n        uint blockSlope = 0;\n        // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope =\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\n                (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        {\n            uint ti = (lastCheckpoint / WEEK) * WEEK;\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            for (uint i = 0; i < 255; ++i) {\n                ti += WEEK;\n                int128 dSlope = 0;\n                if (ti > block.timestamp) {\n                    ti = block.timestamp;\n                } else {\n                    dSlope = slopeChanges[ti];\n                }\n                lastPoint.bias = Math.positiveInt128(\n                    lastPoint.bias -\n                        lastPoint.slope *\n                        int128(int256(ti - lastCheckpoint))\n                );\n                lastPoint.slope = Math.positiveInt128(lastPoint.slope + dSlope);\n                lastCheckpoint = ti;\n                lastPoint.ts = ti;\n                lastPoint.blk =\n                    initialLastPoint.blk +\n                    (blockSlope * (ti - initialLastPoint.ts)) /\n                    MULTIPLIER;\n                _epoch += 1;\n                if (ti == block.timestamp) {\n                    lastPoint.blk = block.number;\n                    break;\n                } else {\n                    _pointHistory[_epoch] = lastPoint;\n                }\n            }\n        }\n\n        epoch = _epoch;\n        // Now pointHistory is filled until t=now\n\n        if (_tokenId != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope = Math.positiveInt128(\n                lastPoint.slope + (uNew.slope - uOld.slope)\n            );\n            lastPoint.bias = Math.positiveInt128(\n                lastPoint.bias + (uNew.bias - uOld.bias)\n            );\n        }\n\n        // Record the changed point into history\n        _pointHistory[_epoch] = lastPoint;\n\n        if (_tokenId != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract newUserSlope from [newLocked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (oldLocked.end > block.timestamp) {\n                // old_dslope was <something> - u_old.slope, so we cancel that\n                oldDSlope += uOld.slope;\n                if (newLocked.end == oldLocked.end) {\n                    oldDSlope -= uNew.slope;\n                    // It was a new deposit, not extension\n                }\n                slopeChanges[oldLocked.end] = oldDSlope;\n            }\n\n            if (newLocked.end > block.timestamp) {\n                if (newLocked.end > oldLocked.end) {\n                    newDSlope -= uNew.slope;\n                    // old slope disappeared at this point\n                    slopeChanges[newLocked.end] = newDSlope;\n                }\n                // else: we recorded it already in oldDSlope\n            }\n            // Now handle user history\n            uint userEpoch = userPointEpoch[_tokenId] + 1;\n\n            userPointEpoch[_tokenId] = userEpoch;\n            uNew.ts = block.timestamp;\n            uNew.blk = block.number;\n            _userPointHistory[_tokenId][userEpoch] = uNew;\n        }\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    /// @param _tokenId NFT that holds lock\n    /// @param _value Amount to deposit\n    /// @param unlockTime New time when to unlock the tokens, or 0 if unchanged\n    /// @param lockedBalance Previous locked amount / timestamp\n    /// @param depositType The type of deposit\n    function _depositFor(\n        uint _tokenId,\n        uint _value,\n        uint unlockTime,\n        LockedBalance memory lockedBalance,\n        DepositType depositType\n    ) internal {\n        LockedBalance memory _locked = lockedBalance;\n        uint supplyBefore = supply;\n\n        supply = supplyBefore + _value;\n        LockedBalance memory oldLocked;\n        (oldLocked.amount, oldLocked.end) = (_locked.amount, _locked.end);\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        _locked.amount += int128(int256(_value));\n        if (unlockTime != 0) {\n            _locked.end = unlockTime;\n        }\n        locked[_tokenId] = _locked;\n\n        // Possibilities:\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // _locked.end > block.timestamp (always)\n        _checkpoint(_tokenId, oldLocked, _locked);\n\n        address from = msg.sender;\n        if (_value != 0 && depositType != DepositType.MERGE_TYPE) {\n            IERC20(token).safeTransferFrom(from, address(this), _value);\n        }\n\n        emit Deposit(\n            from,\n            _tokenId,\n            _value,\n            _locked.end,\n            depositType,\n            block.timestamp\n        );\n        emit Supply(supplyBefore, supplyBefore + _value);\n    }\n\n    function voting(uint _tokenId) external override {\n        require(msg.sender == _voter(), \"!voter\");\n        voted[_tokenId] = true;\n    }\n\n    function abstain(uint _tokenId) external override {\n        require(msg.sender == _voter(), \"!voter\");\n        voted[_tokenId] = false;\n    }\n\n    function attachToken(uint _tokenId) external override {\n        require(msg.sender == _voter(), \"!voter\");\n        attachments[_tokenId] = attachments[_tokenId] + 1;\n    }\n\n    function detachToken(uint _tokenId) external override {\n        require(msg.sender == _voter(), \"!voter\");\n        attachments[_tokenId] = attachments[_tokenId] - 1;\n    }\n\n    function merge(uint _from, uint _to) external {\n        require(attachments[_from] == 0 && !voted[_from], \"attached\");\n        require(_from != _to, \"the same\");\n        require(_isApprovedOrOwner(msg.sender, _from), \"!owner from\");\n        require(_isApprovedOrOwner(msg.sender, _to), \"!owner to\");\n\n        LockedBalance memory _locked0 = locked[_from];\n        LockedBalance memory _locked1 = locked[_to];\n        uint value0 = uint(int256(_locked0.amount));\n        uint end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\n\n        locked[_from] = LockedBalance(0, 0);\n        _checkpoint(_from, _locked0, LockedBalance(0, 0));\n        _burn(_from);\n        _depositFor(_to, value0, end, _locked1, DepositType.MERGE_TYPE);\n    }\n\n    function block_number() external view returns (uint) {\n        return block.number;\n    }\n\n    /// @notice Record global data to checkpoint\n    function checkpoint() external override {\n        _checkpoint(0, LockedBalance(0, 0), LockedBalance(0, 0));\n    }\n\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _tokenId lock NFT\n    /// @param _value Amount to add to user's lock\n    function depositFor(uint _tokenId, uint _value) external override lock {\n        require(_value > 0, \"zero value\");\n        LockedBalance memory _locked = locked[_tokenId];\n        require(_locked.amount > 0, \"No existing lock found\");\n        require(\n            _locked.end > block.timestamp,\n            \"Cannot add to expired lock. Withdraw\"\n        );\n        _depositFor(_tokenId, _value, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _createLock(\n        uint _value,\n        uint _lockDuration,\n        address _to\n    ) internal returns (uint) {\n        require(_value > 0, \"zero value\");\n        // Lock time is rounded down to weeks\n        uint unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK;\n        require(\n            unlockTime > block.timestamp,\n            \"Can only lock until time in the future\"\n        );\n        require(\n            unlockTime <= block.timestamp + MAX_TIME,\n            \"Voting lock can be 4 years max\"\n        );\n\n        ++tokenId;\n        uint _tokenId = tokenId;\n        _mint(_to, _tokenId);\n\n        _depositFor(\n            _tokenId,\n            _value,\n            unlockTime,\n            locked[_tokenId],\n            DepositType.CREATE_LOCK_TYPE\n        );\n        return _tokenId;\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function createLockFor(\n        uint _value,\n        uint _lockDuration,\n        address _to\n    ) external override lock returns (uint) {\n        return _createLock(_value, _lockDuration, _to);\n    }\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n    function createLock(uint _value, uint _lockDuration)\n        external\n        lock\n        returns (uint)\n    {\n        return _createLock(_value, _lockDuration, msg.sender);\n    }\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function increaseAmount(uint _tokenId, uint _value) external lock {\n        LockedBalance memory _locked = locked[_tokenId];\n        require(_locked.amount > 0, \"No existing lock found\");\n        require(\n            _locked.end > block.timestamp,\n            \"Cannot add to expired lock. Withdraw\"\n        );\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"!owner\");\n        require(_value > 0, \"zero value\");\n\n        _depositFor(\n            _tokenId,\n            _value,\n            0,\n            _locked,\n            DepositType.INCREASE_LOCK_AMOUNT\n        );\n    }\n\n    /// @notice Extend the unlock time for `_tokenId`\n    /// @param _lockDuration New number of seconds until tokens unlock\n    function increaseUnlockTime(uint _tokenId, uint _lockDuration)\n        external\n        lock\n    {\n        LockedBalance memory _locked = locked[_tokenId];\n        // Lock time is rounded down to weeks\n        uint unlockTime = ((block.timestamp + _lockDuration) / WEEK) * WEEK;\n        require(_locked.amount > 0, \"Nothing is locked\");\n        require(_locked.end > block.timestamp, \"Lock expired\");\n        require(unlockTime > _locked.end, \"Can only increase lock duration\");\n        require(\n            unlockTime <= block.timestamp + MAX_TIME,\n            \"Voting lock can be 4 years max\"\n        );\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"!owner\");\n\n        _depositFor(\n            _tokenId,\n            0,\n            unlockTime,\n            _locked,\n            DepositType.INCREASE_UNLOCK_TIME\n        );\n    }\n\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdraw(uint _tokenId) external lock {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"!owner\");\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\");\n        LockedBalance memory _locked = locked[_tokenId];\n        require(block.timestamp >= _locked.end, \"The lock did not expire\");\n\n        uint value = uint(int256(_locked.amount));\n        locked[_tokenId] = LockedBalance(0, 0);\n        uint supplyBefore = supply;\n        supply = supplyBefore - value;\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(_tokenId, _locked, LockedBalance(0, 0));\n\n        IERC20(token).safeTransfer(msg.sender, value);\n\n        // Burn the NFT\n        _burn(_tokenId);\n\n        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\n        emit Supply(supplyBefore, supplyBefore - value);\n    }\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    /// @notice Binary search to estimate timestamp for block number\n    /// @param _block Block to find\n    /// @param maxEpoch Don't go beyond this epoch\n    /// @return Approximate timestamp for block\n    function _findBlockEpoch(uint _block, uint maxEpoch)\n        internal\n        view\n        returns (uint)\n    {\n        // Binary search\n        uint _min = 0;\n        uint _max = maxEpoch;\n        for (uint i = 0; i < 128; ++i) {\n            // Will be always enough for 128-bit numbers\n            if (_min >= _max) {\n                break;\n            }\n            uint _mid = (_min + _max + 1) / 2;\n            if (_pointHistory[_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    /// @notice Get the current voting power for `_tokenId`\n    /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n    /// @param _tokenId NFT for lock\n    /// @param _t Epoch time to return voting power at\n    /// @return User voting power\n    function _balanceOfNFT(uint _tokenId, uint _t)\n        internal\n        view\n        returns (uint)\n    {\n        uint _epoch = userPointEpoch[_tokenId];\n        if (_epoch == 0) {\n            return 0;\n        } else {\n            Point memory lastPoint = _userPointHistory[_tokenId][_epoch];\n            lastPoint.bias -=\n                lastPoint.slope *\n                int128(int256(_t) - int256(lastPoint.ts));\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            return uint(int256(lastPoint.bias));\n        }\n    }\n\n    /// @dev Returns current token URI metadata\n    /// @param _tokenId Token ID to fetch URI for.\n    function tokenURI(uint _tokenId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        require(\n            idToOwner[_tokenId] != address(0),\n            \"Query for nonexistent token\"\n        );\n        LockedBalance memory _locked = locked[_tokenId];\n        return\n            _tokenURI(\n                _tokenId,\n                _balanceOfNFT(_tokenId, block.timestamp),\n                _locked.end,\n                uint(int256(_locked.amount))\n            );\n    }\n\n    function balanceOfNFT(uint _tokenId) external view override returns (uint) {\n        // flash NFT protection\n        if (ownershipChange[_tokenId] == block.number) {\n            return 0;\n        }\n        return _balanceOfNFT(_tokenId, block.timestamp);\n    }\n\n    function balanceOfNFTAt(uint _tokenId, uint _t)\n        external\n        view\n        returns (uint)\n    {\n        return _balanceOfNFT(_tokenId, _t);\n    }\n\n    /// @notice Measure voting power of `_tokenId` at block height `_block`\n    /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n    /// @param _tokenId User's wallet NFT\n    /// @param _block Block to calculate the voting power at\n    /// @return Voting power\n    function _balanceOfAtNFT(uint _tokenId, uint _block)\n        internal\n        view\n        returns (uint)\n    {\n        // Copying and pasting totalSupply code because Vyper cannot pass by\n        // reference yet\n        require(_block <= block.number, \"only old block\");\n\n        // Binary search\n        uint _min = 0;\n        uint _max = userPointEpoch[_tokenId];\n        for (uint i = 0; i < 128; ++i) {\n            // Will be always enough for 128-bit numbers\n            if (_min >= _max) {\n                break;\n            }\n            uint _mid = (_min + _max + 1) / 2;\n            if (_userPointHistory[_tokenId][_mid].blk <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n\n        Point memory uPoint = _userPointHistory[_tokenId][_min];\n\n        uint maxEpoch = epoch;\n        uint _epoch = _findBlockEpoch(_block, maxEpoch);\n        Point memory point0 = _pointHistory[_epoch];\n        uint dBlock = 0;\n        uint dt = 0;\n        if (_epoch < maxEpoch) {\n            Point memory point1 = _pointHistory[_epoch + 1];\n            dBlock = point1.blk - point0.blk;\n            dt = point1.ts - point0.ts;\n        } else {\n            dBlock = block.number - point0.blk;\n            dt = block.timestamp - point0.ts;\n        }\n        uint blockTime = point0.ts;\n        if (dBlock != 0 && _block > point0.blk) {\n            blockTime += (dt * (_block - point0.blk)) / dBlock;\n        }\n\n        uPoint.bias -= uPoint.slope * int128(int256(blockTime - uPoint.ts));\n        return uint(uint128(Math.positiveInt128(uPoint.bias)));\n    }\n\n    function balanceOfAtNFT(uint _tokenId, uint _block)\n        external\n        view\n        returns (uint)\n    {\n        return _balanceOfAtNFT(_tokenId, _block);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param point The point (bias/slope) to start search from\n    /// @param t Time to calculate the total voting power at\n    /// @return Total voting power at that time\n    function _supplyAt(Point memory point, uint t)\n        internal\n        view\n        returns (uint)\n    {\n        Point memory lastPoint = point;\n        uint ti = (lastPoint.ts / WEEK) * WEEK;\n        for (uint i = 0; i < 255; ++i) {\n            ti += WEEK;\n            int128 dSlope = 0;\n            if (ti > t) {\n                ti = t;\n            } else {\n                dSlope = slopeChanges[ti];\n            }\n            lastPoint.bias -=\n                lastPoint.slope *\n                int128(int256(ti - lastPoint.ts));\n            if (ti == t) {\n                break;\n            }\n            lastPoint.slope += dSlope;\n            lastPoint.ts = ti;\n        }\n        return uint(uint128(Math.positiveInt128(lastPoint.bias)));\n    }\n\n    /// @notice Calculate total voting power\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    /// @return Total voting power\n    function totalSupplyAtT(uint t) public view returns (uint) {\n        uint _epoch = epoch;\n        Point memory lastPoint = _pointHistory[_epoch];\n        return _supplyAt(lastPoint, t);\n    }\n\n    function totalSupply() external view returns (uint) {\n        return totalSupplyAtT(block.timestamp);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _block Block to calculate the total voting power at\n    /// @return Total voting power at `_block`\n    function totalSupplyAt(uint _block) external view returns (uint) {\n        require(_block <= block.number, \"only old blocks\");\n        uint _epoch = epoch;\n        uint targetEpoch = _findBlockEpoch(_block, _epoch);\n\n        Point memory point = _pointHistory[targetEpoch];\n        // it is possible only for a block before the launch\n        // return 0 as more clear answer than revert\n        if (point.blk > _block) {\n            return 0;\n        }\n        uint dt = 0;\n        if (targetEpoch < _epoch) {\n            Point memory point_next = _pointHistory[targetEpoch + 1];\n            // next point block can not be the same or lower\n            dt =\n                ((_block - point.blk) * (point_next.ts - point.ts)) /\n                (point_next.blk - point.blk);\n        } else {\n            if (point.blk != block.number) {\n                dt =\n                    ((_block - point.blk) * (block.timestamp - point.ts)) /\n                    (block.number - point.blk);\n            }\n        }\n        // Now dt contains info on how far are we beyond point\n        return _supplyAt(point, point.ts + dt);\n    }\n\n    function _tokenURI(\n        uint _tokenId,\n        uint _balanceOf,\n        uint _locked_end,\n        uint _value\n    ) internal pure returns (string memory output) {\n        output = \"<svg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMinYMin meet' viewBox='0 0 350 350'><style>.base { fill: black; font-family: Impact; font-size: 50px; }</style><rect width='100%' height='100%' fill='#aaaaff' /><text x='10' y='60' class='base'>\";\n        output = string(\n            abi.encodePacked(\n                output,\n                \"token \",\n                _toString(_tokenId),\n                \"</text><text x='10' y='150' class='base'>\"\n            )\n        );\n        output = string(\n            abi.encodePacked(\n                output,\n                \"balanceOf \",\n                _toString(_balanceOf),\n                \"</text><text x='10' y='230' class='base'>\"\n            )\n        );\n        output = string(\n            abi.encodePacked(\n                output,\n                \"locked_end \",\n                _toString(_locked_end),\n                \"</text><text x='10' y='310' class='base'>\"\n            )\n        );\n        output = string(\n            abi.encodePacked(\n                output,\n                \"value \",\n                _toString(_value),\n                \"</text></svg>\"\n            )\n        );\n\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        \"{'name': 'lock #\",\n                        _toString(_tokenId),\n                        \"', 'description': 'Voltswap locks, can be used to boost gauge yields, vote on token emission, and receive bribes', 'image': 'data:image/svg+xml;base64,\",\n                        Base64.encode(bytes(output)),\n                        \"'}\"\n                    )\n                )\n            )\n        );\n        output = string(\n            abi.encodePacked(\"data:application/json;base64,\", json)\n        );\n    }\n\n    function _toString(uint value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT license\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function _burn(uint _tokenId) internal {\n        address owner = ownerOf(_tokenId);\n        // Clear approval\n        approve(address(0), _tokenId);\n        // Remove token\n        _removeTokenFrom(msg.sender, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n\n    function userPointHistory(uint _tokenId, uint _loc)\n        external\n        view\n        override\n        returns (Point memory)\n    {\n        return _userPointHistory[_tokenId][_loc];\n    }\n\n    function pointHistory(uint _loc)\n        external\n        view\n        override\n        returns (Point memory)\n    {\n        return _pointHistory[_loc];\n    }\n}\n"
    },
    "contracts/lib/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\n                )\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n"
    },
    "contracts/interface/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interface/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/interface/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IController {\n    function veDist() external view returns (address);\n\n    function voter() external view returns (address);\n}\n"
    },
    "contracts/lib/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nlibrary Math {\n    function max(uint a, uint b) internal pure returns (uint) {\n        return a >= b ? a : b;\n    }\n\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n\n    function positiveInt128(int128 value) internal pure returns (int128) {\n        return value < 0 ? int128(0) : value;\n    }\n\n    function closeTo(\n        uint a,\n        uint b,\n        uint target\n    ) internal pure returns (bool) {\n        if (a > b) {\n            if (a - b <= target) {\n                return true;\n            }\n        } else {\n            if (b - a <= target) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/test/ContractTestHelper2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../base/core/VoltPair.sol\";\nimport \"../base/vote/Ve.sol\";\n\ncontract ContractTestHelper2 is IERC721Receiver {\n    using SafeERC20 for IERC20;\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        revert(\"stub revert\");\n    }\n}\n"
    },
    "contracts/base/core/VoltPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IERC721Metadata.sol\";\nimport \"../../interface/IPair.sol\";\nimport \"../../interface/IFactory.sol\";\nimport \"../../interface/ICallee.sol\";\nimport \"../../interface/IUnderlying.sol\";\nimport \"./PairFees.sol\";\nimport \"../../lib/Math.sol\";\nimport \"../../lib/SafeERC20.sol\";\nimport \"../Reentrancy.sol\";\n\n// The base pair of pools, either stable or volatile\ncontract VoltPair is IERC20, IPair, Reentrancy {\n    using SafeERC20 for IERC20;\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    /// @dev Used to denote stable or volatile pair\n    bool public stable;\n\n    uint public override totalSupply = 0;\n\n    mapping(address => mapping(address => uint)) public override allowance;\n    mapping(address => uint) public override balanceOf;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    uint internal constant _FEE_PRECISION = 1e32;\n    mapping(address => uint) public nonces;\n    uint public chainId;\n\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\n    /// @dev 50% of swap fee\n    uint internal constant TREASURY_FEE = 2;\n    /// @dev Capture oracle reading every 30 minutes\n    uint internal constant PERIOD_SIZE = 1800;\n\n    address public override token0;\n    address public override token1;\n    address public fees;\n    address public factory;\n\n    Observation[] public observations;\n\n    uint internal decimals0;\n    uint internal decimals1;\n\n    uint public reserve0;\n    uint public reserve1;\n    uint public blockTimestampLast;\n\n    uint public reserve0CumulativeLast;\n    uint public reserve1CumulativeLast;\n\n    // index0 and index1 are used to accumulate fees,\n    // this is split out from normal trades to keep the swap \"clean\"\n    // this further allows LP holders to easily claim fees for tokens they have/staked\n    uint public index0 = 0;\n    uint public index1 = 0;\n\n    // position assigned to each LP to track their current index0 & index1 vs the global position\n    mapping(address => uint) public supplyIndex0;\n    mapping(address => uint) public supplyIndex1;\n\n    // tracks the amount of unclaimed, but claimable tokens off of fees for token0 and token1\n    mapping(address => uint) public claimable0;\n    mapping(address => uint) public claimable1;\n\n    event Treasury(address indexed sender, uint amount0, uint amount1);\n    event Fees(address indexed sender, uint amount0, uint amount1);\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(\n        address indexed sender,\n        uint amount0,\n        uint amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint reserve0, uint reserve1);\n    event Claim(\n        address indexed sender,\n        address indexed recipient,\n        uint amount0,\n        uint amount1\n    );\n\n    constructor() {\n        factory = msg.sender;\n        (address _token0, address _token1, bool _stable) = IFactory(msg.sender)\n            .getInitializable();\n        (token0, token1, stable) = (_token0, _token1, _stable);\n        fees = address(new PairFees(_token0, _token1));\n        if (_stable) {\n            name = string(\n                abi.encodePacked(\n                    \"StableV1 AMM - \",\n                    IERC721Metadata(_token0).symbol(),\n                    \"/\",\n                    IERC721Metadata(_token1).symbol()\n                )\n            );\n            symbol = string(\n                abi.encodePacked(\n                    \"sAMM-\",\n                    IERC721Metadata(_token0).symbol(),\n                    \"/\",\n                    IERC721Metadata(_token1).symbol()\n                )\n            );\n        } else {\n            name = string(\n                abi.encodePacked(\n                    \"VolatileV1 AMM - \",\n                    IERC721Metadata(_token0).symbol(),\n                    \"/\",\n                    IERC721Metadata(_token1).symbol()\n                )\n            );\n            symbol = string(\n                abi.encodePacked(\n                    \"vAMM-\",\n                    IERC721Metadata(_token0).symbol(),\n                    \"/\",\n                    IERC721Metadata(_token1).symbol()\n                )\n            );\n        }\n\n        decimals0 = 10**IUnderlying(_token0).decimals();\n        decimals1 = 10**IUnderlying(_token1).decimals();\n\n        observations.push(Observation(block.timestamp, 0, 0));\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(\"1\"),\n                block.chainid,\n                address(this)\n            )\n        );\n        chainId = block.chainid;\n    }\n\n    function observationLength() external view returns (uint) {\n        return observations.length;\n    }\n\n    function lastObservation() public view returns (Observation memory) {\n        return observations[observations.length - 1];\n    }\n\n    function metadata()\n        external\n        view\n        returns (\n            uint dec0,\n            uint dec1,\n            uint r0,\n            uint r1,\n            bool st,\n            address t0,\n            address t1\n        )\n    {\n        return (\n            decimals0,\n            decimals1,\n            reserve0,\n            reserve1,\n            stable,\n            token0,\n            token1\n        );\n    }\n\n    function tokens() external view override returns (address, address) {\n        return (token0, token1);\n    }\n\n    /// @dev Claim accumulated but unclaimed fees (viewable via claimable0 and claimable1)\n    function claimFees()\n        external\n        override\n        returns (uint claimed0, uint claimed1)\n    {\n        _updateFor(msg.sender);\n\n        claimed0 = claimable0[msg.sender];\n        claimed1 = claimable1[msg.sender];\n\n        if (claimed0 > 0 || claimed1 > 0) {\n            claimable0[msg.sender] = 0;\n            claimable1[msg.sender] = 0;\n\n            PairFees(fees).claimFeesFor(msg.sender, claimed0, claimed1);\n\n            emit Claim(msg.sender, msg.sender, claimed0, claimed1);\n        }\n    }\n\n    /// @dev Accrue fees on token0\n    function _update0(uint amount) internal {\n        uint toTreasury;\n        address treasury = IFactory(factory).treasury();\n        if (treasury != address(0)) {\n            toTreasury = amount / TREASURY_FEE;\n            // transfer the fees out to PairFees and Treasury\n            IERC20(token0).safeTransfer(treasury, toTreasury);\n            // keep the same structure of events for compatability\n            emit Treasury(msg.sender, toTreasury, 0);\n        }\n        uint toFees = amount - toTreasury;\n        IERC20(token0).safeTransfer(fees, toFees);\n        // 1e32 adjustment is removed during claim\n        uint _ratio = (toFees * _FEE_PRECISION) / totalSupply;\n        if (_ratio > 0) {\n            index0 += _ratio;\n        }\n        emit Fees(msg.sender, toFees, 0);\n    }\n\n    /// @dev Accrue fees on token1\n    function _update1(uint amount) internal {\n        uint toTreasury;\n        address treasury = IFactory(factory).treasury();\n        if (treasury != address(0)) {\n            toTreasury = amount / TREASURY_FEE;\n            // transfer the fees out to PairFees and Treasury\n            IERC20(token1).safeTransfer(treasury, toTreasury);\n            // keep the same structure of events for compatability\n            emit Treasury(msg.sender, 0, toTreasury);\n        }\n        uint toFees = amount - toTreasury;\n        IERC20(token1).safeTransfer(fees, toFees);\n        uint _ratio = (toFees * _FEE_PRECISION) / totalSupply;\n        if (_ratio > 0) {\n            index1 += _ratio;\n        }\n        emit Fees(msg.sender, 0, toFees);\n    }\n\n    /// @dev This function MUST be called on any balance changes,\n    ///      otherwise can be used to infinitely claim fees\n    //       Fees are segregated from core funds, so fees can never put liquidity at risk\n    function _updateFor(address recipient) internal {\n        uint _supplied = balanceOf[recipient];\n        // get LP balance of `recipient`\n        if (_supplied > 0) {\n            uint _supplyIndex0 = supplyIndex0[recipient];\n            // get last adjusted index0 for recipient\n            uint _supplyIndex1 = supplyIndex1[recipient];\n            uint _index0 = index0;\n            // get global index0 for accumulated fees\n            uint _index1 = index1;\n            supplyIndex0[recipient] = _index0;\n            // update user current position to global position\n            supplyIndex1[recipient] = _index1;\n            uint _delta0 = _index0 - _supplyIndex0;\n            // see if there is any difference that need to be accrued\n            uint _delta1 = _index1 - _supplyIndex1;\n            if (_delta0 > 0) {\n                uint _share = (_supplied * _delta0) / _FEE_PRECISION;\n                // add accrued difference for each supplied token\n                claimable0[recipient] += _share;\n            }\n            if (_delta1 > 0) {\n                uint _share = (_supplied * _delta1) / _FEE_PRECISION;\n                claimable1[recipient] += _share;\n            }\n        } else {\n            supplyIndex0[recipient] = index0;\n            // new users are set to the default global state\n            supplyIndex1[recipient] = index1;\n        }\n    }\n\n    function getReserves()\n        public\n        view\n        override\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = uint112(reserve0);\n        _reserve1 = uint112(reserve1);\n        _blockTimestampLast = uint32(blockTimestampLast);\n    }\n\n    /// @dev Update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint balance0,\n        uint balance1,\n        uint _reserve0,\n        uint _reserve1\n    ) internal {\n        uint blockTimestamp = block.timestamp;\n        uint timeElapsed = blockTimestamp - blockTimestampLast;\n        // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            unchecked {\n                reserve0CumulativeLast += _reserve0 * timeElapsed;\n                reserve1CumulativeLast += _reserve1 * timeElapsed;\n            }\n        }\n\n        Observation memory _point = lastObservation();\n        timeElapsed = blockTimestamp - _point.timestamp;\n        // compare the last observation with current timestamp,\n        // if greater than 30 minutes, record a new event\n        if (timeElapsed > PERIOD_SIZE) {\n            observations.push(\n                Observation(\n                    blockTimestamp,\n                    reserve0CumulativeLast,\n                    reserve1CumulativeLast\n                )\n            );\n        }\n        reserve0 = balance0;\n        reserve1 = balance1;\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    /// @dev Produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices()\n        public\n        view\n        returns (\n            uint reserve0Cumulative,\n            uint reserve1Cumulative,\n            uint blockTimestamp\n        )\n    {\n        blockTimestamp = block.timestamp;\n        reserve0Cumulative = reserve0CumulativeLast;\n        reserve1Cumulative = reserve1CumulativeLast;\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (\n            uint _reserve0,\n            uint _reserve1,\n            uint _blockTimestampLast\n        ) = getReserves();\n        if (_blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint timeElapsed = blockTimestamp - _blockTimestampLast;\n            unchecked {\n                reserve0Cumulative += _reserve0 * timeElapsed;\n                reserve1Cumulative += _reserve1 * timeElapsed;\n            }\n        }\n    }\n\n    /// @dev Gives the current twap price measured from amountIn * tokenIn gives amountOut\n    function current(address tokenIn, uint amountIn)\n        external\n        view\n        returns (uint amountOut)\n    {\n        Observation memory _observation = lastObservation();\n        (\n            uint reserve0Cumulative,\n            uint reserve1Cumulative,\n\n        ) = currentCumulativePrices();\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[observations.length - 2];\n        }\n\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        uint _reserve0 = (reserve0Cumulative -\n            _observation.reserve0Cumulative) / timeElapsed;\n        uint _reserve1 = (reserve1Cumulative -\n            _observation.reserve1Cumulative) / timeElapsed;\n        amountOut = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    /// @dev As per `current`, however allows user configured granularity, up to the full window size\n    function quote(\n        address tokenIn,\n        uint amountIn,\n        uint granularity\n    ) external view returns (uint amountOut) {\n        uint[] memory _prices = sample(tokenIn, amountIn, granularity, 1);\n        uint priceAverageCumulative;\n        for (uint i = 0; i < _prices.length; i++) {\n            priceAverageCumulative += _prices[i];\n        }\n        return priceAverageCumulative / granularity;\n    }\n\n    /// @dev Returns a memory set of twap prices\n    function prices(\n        address tokenIn,\n        uint amountIn,\n        uint points\n    ) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, points, 1);\n    }\n\n    function sample(\n        address tokenIn,\n        uint amountIn,\n        uint points,\n        uint window\n    ) public view returns (uint[] memory) {\n        uint[] memory _prices = new uint[](points);\n\n        uint length = observations.length - 1;\n        uint i = length - (points * window);\n        uint nextIndex = 0;\n        uint index = 0;\n\n        for (; i < length; i += window) {\n            nextIndex = i + window;\n            uint timeElapsed = observations[nextIndex].timestamp -\n                observations[i].timestamp;\n            uint _reserve0 = (observations[nextIndex].reserve0Cumulative -\n                observations[i].reserve0Cumulative) / timeElapsed;\n            uint _reserve1 = (observations[nextIndex].reserve1Cumulative -\n                observations[i].reserve1Cumulative) / timeElapsed;\n            _prices[index] = _getAmountOut(\n                amountIn,\n                tokenIn,\n                _reserve0,\n                _reserve1\n            );\n            index = index + 1;\n        }\n        return _prices;\n    }\n\n    /// @dev This low-level function should be called from a contract which performs important safety checks\n    ///      standard uniswap v2 implementation\n    function mint(address to) external override lock returns (uint liquidity) {\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\n        uint _balance0 = IERC20(token0).balanceOf(address(this));\n        uint _balance1 = IERC20(token1).balanceOf(address(this));\n        uint _amount0 = _balance0 - _reserve0;\n        uint _amount1 = _balance1 - _reserve1;\n\n        uint _totalSupply = totalSupply;\n        // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\n            _mint(address(0), MINIMUM_LIQUIDITY);\n        } else {\n            liquidity = Math.min(\n                (_amount0 * _totalSupply) / _reserve0,\n                (_amount1 * _totalSupply) / _reserve1\n            );\n        }\n        require(liquidity > 0, \"VoltPair: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, _amount0, _amount1);\n    }\n\n    /// @dev This low-level function should be called from a contract which performs important safety checks\n    ///      standard uniswap v2 implementation\n    function burn(address to)\n        external\n        override\n        lock\n        returns (uint amount0, uint amount1)\n    {\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\n        (address _token0, address _token1) = (token0, token1);\n        uint _balance0 = IERC20(_token0).balanceOf(address(this));\n        uint _balance1 = IERC20(_token1).balanceOf(address(this));\n        uint _liquidity = balanceOf[address(this)];\n\n        // gas savings, must be defined here since totalSupply can update in _mintFee\n        uint _totalSupply = totalSupply;\n        // using balances ensures pro-rata distribution\n        amount0 = (_liquidity * _balance0) / _totalSupply;\n        // using balances ensures pro-rata distribution\n        amount1 = (_liquidity * _balance1) / _totalSupply;\n        require(\n            amount0 > 0 && amount1 > 0,\n            \"VoltPair: INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n        _burn(address(this), _liquidity);\n        IERC20(_token0).safeTransfer(to, amount0);\n        IERC20(_token1).safeTransfer(to, amount1);\n        _balance0 = IERC20(_token0).balanceOf(address(this));\n        _balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    /// @dev This low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external override lock {\n        require(!IFactory(factory).isPaused(), \"VoltPair: PAUSE\");\n        require(\n            amount0Out > 0 || amount1Out > 0,\n            \"VoltPair: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\n        require(\n            amount0Out < _reserve0 && amount1Out < _reserve1,\n            \"VoltPair: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint _balance0;\n        uint _balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            require(to != _token0 && to != _token1, \"VoltPair: INVALID_TO\");\n            // optimistically transfer tokens\n            if (amount0Out > 0) IERC20(_token0).safeTransfer(to, amount0Out);\n            // optimistically transfer tokens\n            if (amount1Out > 0) IERC20(_token1).safeTransfer(to, amount1Out);\n            // callback, used for flash loans\n            if (data.length > 0)\n                ICallee(to).hook(msg.sender, amount0Out, amount1Out, data);\n            _balance0 = IERC20(_token0).balanceOf(address(this));\n            _balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = _balance0 > _reserve0 - amount0Out\n            ? _balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint amount1In = _balance1 > _reserve1 - amount1Out\n            ? _balance1 - (_reserve1 - amount1Out)\n            : 0;\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"VoltPair: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            // accrue fees for token0 and move them out of pool\n            if (amount0In > 0) _update0(swapFee(amount0In));\n            // accrue fees for token1 and move them out of pool\n            if (amount1In > 0) _update1(swapFee(amount1In));\n            // since we removed tokens, we need to reconfirm balances,\n            // can also simply use previous balance - amountIn/ SWAP_FEE,\n            // but doing balanceOf again as safety check\n            _balance0 = IERC20(_token0).balanceOf(address(this));\n            _balance1 = IERC20(_token1).balanceOf(address(this));\n            // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\n            require(\n                _k(_balance0, _balance1) >= _k(_reserve0, _reserve1),\n                \"VoltPair: K\"\n            );\n        }\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    /// @dev Force balances to match reserves\n    function skim(address to) external lock {\n        (address _token0, address _token1) = (token0, token1);\n        IERC20(_token0).safeTransfer(\n            to,\n            IERC20(_token0).balanceOf(address(this)) - (reserve0)\n        );\n        IERC20(_token1).safeTransfer(\n            to,\n            IERC20(_token1).balanceOf(address(this)) - (reserve1)\n        );\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n\n    function _f(uint x0, uint y) internal pure returns (uint) {\n        return\n            (x0 * ((((y * y) / 1e18) * y) / 1e18)) /\n            1e18 +\n            (((((x0 * x0) / 1e18) * x0) / 1e18) * y) /\n            1e18;\n    }\n\n    function _d(uint x0, uint y) internal pure returns (uint) {\n        return\n            (3 * x0 * ((y * y) / 1e18)) /\n            1e18 +\n            ((((x0 * x0) / 1e18) * x0) / 1e18);\n    }\n\n    function _getY(\n        uint x0,\n        uint xy,\n        uint y\n    ) internal pure returns (uint) {\n        for (uint i = 0; i < 255; i++) {\n            uint yPrev = y;\n            uint k = _f(x0, y);\n            if (k < xy) {\n                uint dy = ((xy - k) * 1e18) / _d(x0, y);\n                y = y + dy;\n            } else {\n                uint dy = ((k - xy) * 1e18) / _d(x0, y);\n                y = y - dy;\n            }\n            if (Math.closeTo(y, yPrev, 1)) {\n                break;\n            }\n        }\n        return y;\n    }\n\n    function getAmountOut(uint amountIn, address tokenIn)\n        external\n        view\n        override\n        returns (uint)\n    {\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\n        // remove fee from amount received\n        amountIn -= swapFee(amountIn);\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    function _getAmountOut(\n        uint amountIn,\n        address tokenIn,\n        uint _reserve0,\n        uint _reserve1\n    ) internal view returns (uint) {\n        if (stable) {\n            uint xy = _k(_reserve0, _reserve1);\n            _reserve0 = (_reserve0 * 1e18) / decimals0;\n            _reserve1 = (_reserve1 * 1e18) / decimals1;\n            (uint reserveA, uint reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            amountIn = tokenIn == token0\n                ? (amountIn * 1e18) / decimals0\n                : (amountIn * 1e18) / decimals1;\n            uint y = reserveB - _getY(amountIn + reserveA, xy, reserveB);\n            return (y * (tokenIn == token0 ? decimals1 : decimals0)) / 1e18;\n        } else {\n            (uint reserveA, uint reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            return (amountIn * reserveB) / (reserveA + amountIn);\n        }\n    }\n\n    function _k(uint x, uint y) internal view returns (uint) {\n        if (stable) {\n            uint _x = (x * 1e18) / decimals0;\n            uint _y = (y * 1e18) / decimals1;\n            uint _a = (_x * _y) / 1e18;\n            uint _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n            // x3y+y3x >= k\n            return (_a * _b) / 1e18;\n        } else {\n            // xy >= k\n            return x * y;\n        }\n    }\n\n    function swapFee(uint256 amount) internal view returns (uint256) {\n        if (stable) {\n            return (amount * 4) / 10000;\n        } else {\n            return (amount * 3) / 1000;\n        }\n    }\n\n    //****************************************************************************\n    //**************************** ERC20 *****************************************\n    //****************************************************************************\n\n    function _mint(address dst, uint amount) internal {\n        // balances must be updated on mint/burn/transfer\n        _updateFor(dst);\n        totalSupply += amount;\n        balanceOf[dst] += amount;\n        emit Transfer(address(0), dst, amount);\n    }\n\n    function _burn(address dst, uint amount) internal {\n        _updateFor(dst);\n        totalSupply -= amount;\n        balanceOf[dst] -= amount;\n        emit Transfer(dst, address(0), amount);\n    }\n\n    function approve(address spender, uint amount)\n        external\n        override\n        returns (bool)\n    {\n        require(spender != address(0), \"VoltPair: Approve to the zero address\");\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"VoltPair: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"VoltPair: INVALID_SIGNATURE\"\n        );\n        allowance[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    function transfer(address dst, uint amount)\n        external\n        override\n        returns (bool)\n    {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint amount\n    ) external override returns (bool) {\n        address spender = msg.sender;\n        uint spenderAllowance = allowance[src][spender];\n\n        if (spender != src && spenderAllowance != type(uint).max) {\n            require(\n                spenderAllowance >= amount,\n                \"VoltPair: Insufficient allowance\"\n            );\n            unchecked {\n                uint newAllowance = spenderAllowance - amount;\n                allowance[src][spender] = newAllowance;\n                emit Approval(src, spender, newAllowance);\n            }\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    function _transferTokens(\n        address src,\n        address dst,\n        uint amount\n    ) internal {\n        require(dst != address(0), \"VoltPair: Transfer to the zero address\");\n\n        // update fee position for src\n        _updateFor(src);\n        // update fee position for dst\n        _updateFor(dst);\n\n        uint srcBalance = balanceOf[src];\n        require(\n            srcBalance >= amount,\n            \"VoltPair: Transfer amount exceeds balance\"\n        );\n        unchecked {\n            balanceOf[src] = srcBalance - amount;\n        }\n\n        balanceOf[dst] += amount;\n\n        emit Transfer(src, dst, amount);\n    }\n}\n"
    },
    "contracts/interface/ICallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface ICallee {\n    function hook(\n        address sender,\n        uint amount0,\n        uint amount1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interface/IUnderlying.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IUnderlying {\n    function approve(address spender, uint value) external returns (bool);\n\n    function mint(address, uint) external;\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address) external view returns (uint);\n\n    function transfer(address, uint) external returns (bool);\n\n    function decimals() external returns (uint8);\n}\n"
    },
    "contracts/base/core/PairFees.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IERC20.sol\";\nimport \"../../lib/SafeERC20.sol\";\n\n/// @title Base V1 Fees contract is used as a 1:1 pair relationship to split out fees,\n///        this ensures that the curve does not need to be modified for LP shares\ncontract PairFees {\n    using SafeERC20 for IERC20;\n\n    /// @dev The pair it is bonded to\n    address internal pair;\n    /// @dev Token0 of pair, saved localy and statically for gas optimization\n    address internal token0;\n    /// @dev Token1 of pair, saved localy and statically for gas optimization\n    address internal token1;\n\n    constructor(address _token0, address _token1) {\n        pair = msg.sender;\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // Allow the pair to transfer fees to users\n    function claimFeesFor(\n        address recipient,\n        uint amount0,\n        uint amount1\n    ) external {\n        require(msg.sender == pair, \"Not pair\");\n        if (amount0 > 0) {\n            IERC20(token0).safeTransfer(recipient, amount0);\n        }\n        if (amount1 > 0) {\n            IERC20(token1).safeTransfer(recipient, amount1);\n        }\n    }\n}\n"
    },
    "contracts/test/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../lib/Address.sol\";\nimport \"../lib/Base64.sol\";\nimport \"../lib/CheckpointLib.sol\";\nimport \"../lib/Math.sol\";\nimport \"../base/core/VoltPair.sol\";\n\ncontract Token {\n    using Address for address;\n    using CheckpointLib for mapping(uint => CheckpointLib.Checkpoint);\n\n    string public symbol;\n    string public name;\n    uint256 public decimals;\n    uint256 public totalSupply = 0;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(uint => CheckpointLib.Checkpoint) private _checkpoints;\n\n    event Transfer(address from, address to, uint256 value);\n    event Approval(address owner, address spender, uint256 value);\n    event LogChangeVault(\n        address indexed oldVault,\n        address indexed newVault,\n        uint indexed effectiveTime\n    );\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _decimals,\n        address\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        {\n            DOMAIN_SEPARATOR = keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(\"1\")),\n                    chainId,\n                    address(this)\n                )\n            );\n            _mint(msg.sender, 0);\n        }\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"StableV1: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"StableV1: INVALID_SIGNATURE\"\n        );\n        allowance[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    function token() external view returns (address) {\n        return address(this);\n    }\n\n    function balance(address account) external view returns (uint) {\n        return balanceOf[account];\n    }\n\n    function claimFees() external pure returns (uint, uint) {\n        return (0, 0);\n    }\n\n    function _mint(address _to, uint _amount) internal returns (bool) {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n        emit Transfer(address(0x0), _to, _amount);\n        return true;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool) {\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool) {\n        uint256 allowed_from = allowance[_from][msg.sender];\n        require(allowance[_from][msg.sender] >= _value, \"Not enough allowance\");\n        if (allowed_from != type(uint).max) {\n            allowance[_from][msg.sender] -= _value;\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    function mint(address account, uint256 amount) external returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    function burn(address account, uint256 amount) public returns (bool) {\n        totalSupply -= amount;\n        balanceOf[account] -= amount;\n\n        emit Transfer(account, address(0), amount);\n        return true;\n    }\n\n    function testWrongCall() external {\n        (address(0)).functionCall(\"\", \"\");\n    }\n\n    function testWrongCall2() external {\n        address(this).functionCall(\n            abi.encodeWithSelector(\n                Token(this).transfer.selector,\n                address(this),\n                type(uint).max\n            ),\n            \"wrong\"\n        );\n    }\n\n    function encode64(bytes memory data) external pure returns (string memory) {\n        return Base64.encode(data);\n    }\n\n    function sqrt(uint value) external pure returns (uint) {\n        return Math.sqrt(value);\n    }\n\n    function testWrongCheckpoint() external view {\n        _checkpoints.findLowerIndex(0, 0);\n    }\n\n    function hook(\n        address,\n        uint,\n        uint,\n        bytes calldata data\n    ) external {\n        address pair = abi.decode(data, (address));\n        VoltPair(pair).swap(0, 0, address(this), \"\");\n    }\n\n    // --------------------- WMTR\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n    }\n}\n"
    },
    "contracts/lib/CheckpointLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nlibrary CheckpointLib {\n    /// @notice A checkpoint for uint value\n    struct Checkpoint {\n        uint timestamp;\n        uint value;\n    }\n\n    function findLowerIndex(\n        mapping(uint => Checkpoint) storage checkpoints,\n        uint size,\n        uint timestamp\n    ) internal view returns (uint) {\n        require(size != 0, \"Empty checkpoints\");\n\n        // First check most recent value\n        if (checkpoints[size - 1].timestamp <= timestamp) {\n            return (size - 1);\n        }\n\n        // Next check implicit zero value\n        if (checkpoints[0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = size - 1;\n        while (upper > lower) {\n            // ceil, avoiding overflow\n            uint center = upper - (upper - lower) / 2;\n            Checkpoint memory cp = checkpoints[center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n}\n"
    },
    "contracts/base/vote/VeDist.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../lib/Math.sol\";\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IVeDist.sol\";\nimport \"../../interface/IVe.sol\";\nimport \"../../lib/SafeERC20.sol\";\n\ncontract VeDist is IVeDist {\n    using SafeERC20 for IERC20;\n\n    event CheckpointToken(uint time, uint tokens);\n\n    event Claimed(uint tokenId, uint amount, uint claimEpoch, uint maxEpoch);\n\n    struct ClaimCalculationResult {\n        uint toDistribute;\n        uint userEpoch;\n        uint weekCursor;\n        uint maxUserEpoch;\n        bool success;\n    }\n\n    uint internal constant WEEK = 7 * 86400;\n\n    uint public startTime;\n    uint public timeCursor;\n    mapping(uint => uint) public timeCursorOf;\n    mapping(uint => uint) public userEpochOf;\n\n    uint public lastTokenTime;\n    uint[1000000000000000] public tokensPerWeek;\n\n    address public votingEscrow;\n    address public token;\n    uint public tokenLastBalance;\n\n    uint[1000000000000000] public veSupply;\n\n    address public depositor;\n\n    constructor(address _votingEscrow) {\n        uint _t = (block.timestamp / WEEK) * WEEK;\n        startTime = _t;\n        lastTokenTime = _t;\n        timeCursor = _t;\n        address _token = IVe(_votingEscrow).token();\n        token = _token;\n        votingEscrow = _votingEscrow;\n        depositor = msg.sender;\n        IERC20(_token).safeIncreaseAllowance(_votingEscrow, type(uint).max);\n    }\n\n    function timestamp() external view returns (uint) {\n        return (block.timestamp / WEEK) * WEEK;\n    }\n\n    function _checkpointToken() internal {\n        uint tokenBalance = IERC20(token).balanceOf(address(this));\n        uint toDistribute = tokenBalance - tokenLastBalance;\n        tokenLastBalance = tokenBalance;\n\n        uint t = lastTokenTime;\n        uint sinceLast = block.timestamp - t;\n        lastTokenTime = block.timestamp;\n        uint thisWeek = (t / WEEK) * WEEK;\n        uint nextWeek = 0;\n\n        for (uint i = 0; i < 20; i++) {\n            nextWeek = thisWeek + WEEK;\n            if (block.timestamp < nextWeek) {\n                tokensPerWeek[thisWeek] += _adjustToDistribute(\n                    toDistribute,\n                    block.timestamp,\n                    t,\n                    sinceLast\n                );\n                break;\n            } else {\n                tokensPerWeek[thisWeek] += _adjustToDistribute(\n                    toDistribute,\n                    nextWeek,\n                    t,\n                    sinceLast\n                );\n            }\n            t = nextWeek;\n            thisWeek = nextWeek;\n        }\n        emit CheckpointToken(block.timestamp, toDistribute);\n    }\n\n    /// @dev For testing purposes.\n    function adjustToDistribute(\n        uint toDistribute,\n        uint t0,\n        uint t1,\n        uint sinceLastCall\n    ) external pure returns (uint) {\n        return _adjustToDistribute(toDistribute, t0, t1, sinceLastCall);\n    }\n\n    function _adjustToDistribute(\n        uint toDistribute,\n        uint t0,\n        uint t1,\n        uint sinceLast\n    ) internal pure returns (uint) {\n        if (t0 <= t1 || t0 - t1 == 0 || sinceLast == 0) {\n            return toDistribute;\n        }\n        return (toDistribute * (t0 - t1)) / sinceLast;\n    }\n\n    function checkpointToken() external override {\n        require(msg.sender == depositor, \"!depositor\");\n        _checkpointToken();\n    }\n\n    function _findTimestampEpoch(address ve, uint _timestamp)\n        internal\n        view\n        returns (uint)\n    {\n        uint _min = 0;\n        uint _max = IVe(ve).epoch();\n        for (uint i = 0; i < 128; i++) {\n            if (_min >= _max) break;\n            uint _mid = (_min + _max + 2) / 2;\n            IVe.Point memory pt = IVe(ve).pointHistory(_mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    function findTimestampUserEpoch(\n        address ve,\n        uint tokenId,\n        uint _timestamp,\n        uint maxUserEpoch\n    ) external view returns (uint) {\n        return _findTimestampUserEpoch(ve, tokenId, _timestamp, maxUserEpoch);\n    }\n\n    function _findTimestampUserEpoch(\n        address ve,\n        uint tokenId,\n        uint _timestamp,\n        uint maxUserEpoch\n    ) internal view returns (uint) {\n        uint _min = 0;\n        uint _max = maxUserEpoch;\n        for (uint i = 0; i < 128; i++) {\n            if (_min >= _max) break;\n            uint _mid = (_min + _max + 2) / 2;\n            IVe.Point memory pt = IVe(ve).userPointHistory(tokenId, _mid);\n            if (pt.ts <= _timestamp) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    function veForAt(uint _tokenId, uint _timestamp)\n        external\n        view\n        returns (uint)\n    {\n        address ve = votingEscrow;\n        uint maxUserEpoch = IVe(ve).userPointEpoch(_tokenId);\n        uint epoch = _findTimestampUserEpoch(\n            ve,\n            _tokenId,\n            _timestamp,\n            maxUserEpoch\n        );\n        IVe.Point memory pt = IVe(ve).userPointHistory(_tokenId, epoch);\n        return\n            uint(\n                int256(\n                    Math.positiveInt128(\n                        pt.bias -\n                            pt.slope *\n                            (int128(int256(_timestamp - pt.ts)))\n                    )\n                )\n            );\n    }\n\n    function _checkpointTotalSupply() internal {\n        address ve = votingEscrow;\n        uint t = timeCursor;\n        uint roundedTimestamp = (block.timestamp / WEEK) * WEEK;\n        IVe(ve).checkpoint();\n\n        // assume will be called more frequently than 20 weeks\n        for (uint i = 0; i < 20; i++) {\n            if (t > roundedTimestamp) {\n                break;\n            } else {\n                uint epoch = _findTimestampEpoch(ve, t);\n                IVe.Point memory pt = IVe(ve).pointHistory(epoch);\n                veSupply[t] = _adjustVeSupply(t, pt.ts, pt.bias, pt.slope);\n            }\n            t += WEEK;\n        }\n        timeCursor = t;\n    }\n\n    function adjustVeSupply(\n        uint t,\n        uint ptTs,\n        int128 ptBias,\n        int128 ptSlope\n    ) external pure returns (uint) {\n        return _adjustVeSupply(t, ptTs, ptBias, ptSlope);\n    }\n\n    function _adjustVeSupply(\n        uint t,\n        uint ptTs,\n        int128 ptBias,\n        int128 ptSlope\n    ) internal pure returns (uint) {\n        if (t < ptTs) {\n            return 0;\n        }\n        int128 dt = int128(int256(t - ptTs));\n        if (ptBias < ptSlope * dt) {\n            return 0;\n        }\n        return uint(int256(Math.positiveInt128(ptBias - ptSlope * dt)));\n    }\n\n    function checkpointTotalSupply() external override {\n        _checkpointTotalSupply();\n    }\n\n    function _claim(\n        uint _tokenId,\n        address ve,\n        uint _lastTokenTime\n    ) internal returns (uint) {\n        ClaimCalculationResult memory result = _calculateClaim(\n            _tokenId,\n            ve,\n            _lastTokenTime\n        );\n        if (result.success) {\n            userEpochOf[_tokenId] = result.userEpoch;\n            timeCursorOf[_tokenId] = result.weekCursor;\n            emit Claimed(\n                _tokenId,\n                result.toDistribute,\n                result.userEpoch,\n                result.maxUserEpoch\n            );\n        }\n        return result.toDistribute;\n    }\n\n    function _calculateClaim(\n        uint _tokenId,\n        address ve,\n        uint _lastTokenTime\n    ) internal view returns (ClaimCalculationResult memory) {\n        uint userEpoch;\n        uint toDistribute;\n        uint maxUserEpoch = IVe(ve).userPointEpoch(_tokenId);\n        uint _startTime = startTime;\n\n        if (maxUserEpoch == 0) {\n            return ClaimCalculationResult(0, 0, 0, 0, false);\n        }\n\n        uint weekCursor = timeCursorOf[_tokenId];\n\n        if (weekCursor == 0) {\n            userEpoch = _findTimestampUserEpoch(\n                ve,\n                _tokenId,\n                _startTime,\n                maxUserEpoch\n            );\n        } else {\n            userEpoch = userEpochOf[_tokenId];\n        }\n\n        if (userEpoch == 0) userEpoch = 1;\n\n        IVe.Point memory userPoint = IVe(ve).userPointHistory(\n            _tokenId,\n            userEpoch\n        );\n        if (weekCursor == 0) {\n            weekCursor = ((userPoint.ts + WEEK - 1) / WEEK) * WEEK;\n        }\n        if (weekCursor >= lastTokenTime) {\n            return ClaimCalculationResult(0, 0, 0, 0, false);\n        }\n        if (weekCursor < _startTime) {\n            weekCursor = _startTime;\n        }\n\n        IVe.Point memory oldUserPoint;\n        {\n            for (uint i = 0; i < 50; i++) {\n                if (weekCursor >= _lastTokenTime) {\n                    break;\n                }\n                if (weekCursor >= userPoint.ts && userEpoch <= maxUserEpoch) {\n                    userEpoch += 1;\n                    oldUserPoint = userPoint;\n                    if (userEpoch > maxUserEpoch) {\n                        userPoint = IVe.Point(0, 0, 0, 0);\n                    } else {\n                        userPoint = IVe(ve).userPointHistory(\n                            _tokenId,\n                            userEpoch\n                        );\n                    }\n                } else {\n                    int128 dt = int128(int256(weekCursor - oldUserPoint.ts));\n                    uint balanceOf = uint(\n                        int256(\n                            Math.positiveInt128(\n                                oldUserPoint.bias - dt * oldUserPoint.slope\n                            )\n                        )\n                    );\n                    if (balanceOf == 0 && userEpoch > maxUserEpoch) {\n                        break;\n                    }\n                    toDistribute +=\n                        (balanceOf * tokensPerWeek[weekCursor]) /\n                        veSupply[weekCursor];\n                    weekCursor += WEEK;\n                }\n            }\n        }\n        return\n            ClaimCalculationResult(\n                toDistribute,\n                Math.min(maxUserEpoch, userEpoch - 1),\n                weekCursor,\n                maxUserEpoch,\n                true\n            );\n    }\n\n    function claimable(uint _tokenId) external view returns (uint) {\n        uint _lastTokenTime = (lastTokenTime / WEEK) * WEEK;\n        ClaimCalculationResult memory result = _calculateClaim(\n            _tokenId,\n            votingEscrow,\n            _lastTokenTime\n        );\n        return result.toDistribute;\n    }\n\n    function claim(uint _tokenId) external returns (uint) {\n        if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n        uint _lastTokenTime = lastTokenTime;\n        _lastTokenTime = (_lastTokenTime / WEEK) * WEEK;\n        uint amount = _claim(_tokenId, votingEscrow, _lastTokenTime);\n        if (amount != 0) {\n            IVe(votingEscrow).depositFor(_tokenId, amount);\n            tokenLastBalance -= amount;\n        }\n        return amount;\n    }\n\n    function claimMany(uint[] memory _tokenIds) external returns (bool) {\n        if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n        uint _lastTokenTime = lastTokenTime;\n        _lastTokenTime = (_lastTokenTime / WEEK) * WEEK;\n        address _votingEscrow = votingEscrow;\n        uint total = 0;\n\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint _tokenId = _tokenIds[i];\n            if (_tokenId == 0) break;\n            uint amount = _claim(_tokenId, _votingEscrow, _lastTokenTime);\n            if (amount != 0) {\n                IVe(_votingEscrow).depositFor(_tokenId, amount);\n                total += amount;\n            }\n        }\n        if (total != 0) {\n            tokenLastBalance -= total;\n        }\n\n        return true;\n    }\n\n    // Once off event on contract initialize\n    function setDepositor(address _depositor) external {\n        require(msg.sender == depositor, \"!depositor\");\n        depositor = _depositor;\n    }\n}\n"
    },
    "contracts/interface/IVeDist.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IVeDist {\n    function checkpointToken() external;\n\n    function checkpointTotalSupply() external;\n}\n"
    },
    "contracts/base/token/Minter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../lib/Math.sol\";\nimport \"../../interface/IVe.sol\";\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IVoter.sol\";\nimport \"../../interface/IVeDist.sol\";\nimport \"../../interface/IController.sol\";\nimport \"../../lib/AccessControl.sol\";\n\ncontract Minter is AccessControl {\n    uint256 internal constant _MONTH = 86400 * 7 * 4; // allows minting once per month\n    uint256 public veDistRatio;\n    uint256 public constant VE_DIST_RATIO_MAX = 10000;\n\n    IERC20 public immutable _token;\n    IVe public immutable _ve;\n    address public immutable controller;\n    uint256 public activeperiod;\n\n    event Send(\n        address indexed sender,\n        uint256 veDistAmount,\n        uint256 voterAmount\n    );\n\n    constructor(address __ve, address __controller) {\n        _token = IERC20(IVe(__ve).token());\n        _ve = IVe(__ve);\n        controller = __controller;\n        activeperiod = (block.timestamp / _MONTH) * _MONTH;\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    modifier onlyAdmin() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"forbidden\");\n        _;\n    }\n\n    function adminSetVeRatio(uint256 _veDistRatio) public onlyAdmin {\n        veDistRatio = _veDistRatio;\n    }\n\n    function _veDist() internal view returns (IVeDist) {\n        return IVeDist(IController(controller).veDist());\n    }\n\n    function _voter() internal view returns (IVoter) {\n        return IVoter(IController(controller).voter());\n    }\n\n    function updatePeriod() external onlyAdmin returns (uint256) {\n        uint256 _period = activeperiod;\n        if (block.timestamp >= _period + _MONTH) {\n            _period = (block.timestamp / _MONTH) * _MONTH;\n            activeperiod = _period;\n\n            uint256 _balanceOf = _token.balanceOf(address(this));\n            uint256 veDistAmount = (_balanceOf * veDistRatio) /\n                VE_DIST_RATIO_MAX;\n\n            require(\n                _token.transfer(address(_veDist()), veDistAmount),\n                \"Transfer Fail\"\n            );\n            _veDist().checkpointToken();\n            _veDist().checkpointTotalSupply();\n\n            uint256 voterAmount = _balanceOf - veDistAmount;\n            _token.approve(address(_voter()), voterAmount);\n            _voter().notifyRewardAmount(voterAmount);\n\n            emit Send(msg.sender, veDistRatio, veDistAmount);\n        }\n        return _period;\n    }\n}\n"
    },
    "contracts/lib/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n// This is adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.0/contracts/access/AccessControl.sol\n// The only difference is added getRoleMemberIndex(bytes32 role, address account) function.\n\nimport \"./EnumerableSet.sol\";\nimport \"./Address.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index)\n        public\n        view\n        returns (address)\n    {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the index of the account that have `role`.\n     */\n    function getRoleMemberIndex(bytes32 role, address account)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _roles[role].members._inner._indexes[\n                bytes32(uint256(uint160(account)))\n            ];\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(\n            hasRole(_roles[role].adminRole, msg.sender),\n            \"AccessControl: sender must be an admin to grant\"\n        );\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(\n            hasRole(_roles[role].adminRole, msg.sender),\n            \"AccessControl: sender must be an admin to revoke\"\n        );\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(\n            account == msg.sender,\n            \"AccessControl: can only renounce roles for self\"\n        );\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n}\n"
    },
    "contracts/lib/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // IERC20 Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value)\n        private\n        view\n        returns (bool)\n    {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index)\n        private\n        view\n        returns (bytes32)\n    {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value)\n        internal\n        returns (bool)\n    {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index)\n        internal\n        view\n        returns (bytes32)\n    {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set)\n        internal\n        view\n        returns (bytes32[] memory)\n    {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index)\n        internal\n        view\n        returns (address)\n    {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory)\n    {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index)\n        internal\n        view\n        returns (uint256)\n    {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./interface/IController.sol\";\n\ncontract Controller is IController {\n    address public governance;\n    address public pendingGovernance;\n\n    address public veDist;\n    address public voter;\n\n    event SetGovernance(address value);\n    event SetVeDist(address value);\n    event SetVoter(address value);\n\n    constructor() {\n        governance = msg.sender;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"Not gov\");\n        _;\n    }\n\n    function setGovernance(address _value) external onlyGov {\n        pendingGovernance = _value;\n        emit SetGovernance(_value);\n    }\n\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"Not pending gov\");\n        governance = pendingGovernance;\n    }\n\n    function setVeDist(address _value) external onlyGov {\n        veDist = _value;\n        emit SetVeDist(_value);\n    }\n\n    function setVoter(address _value) external onlyGov {\n        voter = _value;\n        emit SetVoter(_value);\n    }\n}\n"
    },
    "contracts/base/token/DystMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../lib/Math.sol\";\nimport \"../../lib/SafeERC20.sol\";\nimport \"../../interface/IUnderlying.sol\";\nimport \"../../interface/IVoter.sol\";\nimport \"../../interface/IVe.sol\";\nimport \"../../interface/IVeDist.sol\";\nimport \"../../interface/IMinter.sol\";\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IController.sol\";\n\n/// @title  ve(3,3) ,\ncontract DystMinter is IMinter {\n    using SafeERC20 for IERC20;\n\n    /// @dev  00:00 UTC \n    uint internal constant _WEEK = 86400 * 7;\n    /// @dev 52 * 4\n    uint internal constant _LOCK_PERIOD = 86400 * 7 * 52 * 4;\n\n    /// @dev  2%\n    uint internal constant _WEEKLY_EMISSION_DECREASE = 98;\n    uint internal constant _WEEKLY_EMISSION_DECREASE_DENOMINATOR = 100;\n\n    /// @dev  1%\n    uint internal constant _TAIL_EMISSION = 1;\n    uint internal constant _TAIL_EMISSION_DENOMINATOR = 100;\n\n    /// @dev  ve  10%\n    uint internal constant _GROWTH_DIVIDER = 10;\n\n    /// @dev  initialStubCirculationSupply  1%\n    ///      \n    uint internal constant _INITIAL_CIRCULATION_DECREASE = 99;\n    uint internal constant _INITIAL_CIRCULATION_DECREASE_DENOMINATOR = 100;\n\n    /// @dev .\n    ///      .\n    uint internal constant _STUB_CIRCULATION = 10;\n    uint internal constant _STUB_CIRCULATION_DENOMINATOR = 100;\n\n    /// @dev .\n    ///       .\n    uint internal constant _START_BASE_WEEKLY_EMISSION = 20_000_000e18;\n\n    /// @dev \n    IUnderlying public immutable token;\n    /// @dev veNFT\n    IVe public immutable ve;\n    /// @dev ,veDistvoter\n    address public immutable controller;\n    /// @dev  = \n    uint public baseWeeklyEmission = _START_BASE_WEEKLY_EMISSION;\n    /// @dev \n    uint public initialStubCirculation;\n    /// @dev \n    uint public activePeriod;\n\n    /// @dev \n    address internal initializer;\n\n    event Mint(\n        address indexed sender,\n        uint weekly,\n        uint growth,\n        uint circulatingSupply,\n        uint circulatingEmission\n    );\n\n    /**\n     * @dev \n     * @param ve_ veNFT\n     * @param controller_ \n     * @param warmingUpPeriod ,0\n     */\n    constructor(\n        address ve_, // the ve(3,3) system that will be locked into\n        address controller_, // controller with veDist and voter addresses\n        uint warmingUpPeriod // 2 by default\n    ) {\n        initializer = msg.sender;\n        token = IUnderlying(IVe(ve_).token());\n        ve = IVe(ve_);\n        controller = controller_;\n        //  = ( + ( * 7)) / 7 * 7\n        activePeriod =\n            ((block.timestamp + (warmingUpPeriod * _WEEK)) / _WEEK) *\n            _WEEK;\n    }\n\n    /**\n     * @dev  ve \n     * @param claimants \n     * @param amounts \n     * @param totalAmount \n     */\n    function initialize(\n        address[] memory claimants,\n        uint[] memory amounts,\n        uint totalAmount\n    ) external {\n        // \n        require(initializer == msg.sender, \"Not initializer\");\n        // \n        token.mint(address(this), totalAmount);\n        //  =  * 10%\n        initialStubCirculation =\n            (totalAmount * _STUB_CIRCULATION) /\n            _STUB_CIRCULATION_DENOMINATOR;\n        // veMax\n        token.approve(address(ve), type(uint).max);\n        uint sum;\n        // \n        for (uint i = 0; i < claimants.length; i++) {\n            // ve.createLockFor(,4,)\n            ve.createLockFor(amounts[i], _LOCK_PERIOD, claimants[i]);\n            // \n            sum += amounts[i];\n        }\n        // \n        require(sum == totalAmount, \"Wrong totalAmount\");\n        // \n        initializer = address(0);\n        // \n        activePeriod = ((block.timestamp + _WEEK) / _WEEK) * _WEEK;\n    }\n\n    /// @dev controllerveDist\n    function _veDist() internal view returns (IVeDist) {\n        return IVeDist(IController(controller).veDist());\n    }\n\n    /// @dev controllervoter\n    function _voter() internal view returns (IVoter) {\n        return IVoter(IController(controller).voter());\n    }\n\n    /// @dev  -  - veDist  - \n    function circulatingSupply() external view returns (uint) {\n        return _circulatingSupply();\n    }\n\n    /// @dev  = token - veNFT - veDist - \n    function _circulatingSupply() internal view returns (uint) {\n        return\n            token.totalSupply() - // token -\n            IUnderlying(address(ve)).totalSupply() - // ve\n            //  veDist  - \n            // \n            token.balanceOf(address(_veDist())) -\n            // \n            token.balanceOf(address(this));\n    }\n\n    /// @dev \n    function _circulatingSupplyAdjusted() internal view returns (uint) {\n        // \n        // Max(, )\n        return Math.max(_circulatingSupply(), initialStubCirculation);\n    }\n\n    /// @dev  2%/\n    function calculateEmission() external view returns (uint) {\n        return _calculateEmission();\n    }\n\n    function _calculateEmission() internal view returns (uint) {\n        // \n        //  \n        //  *  / token\n        return\n            (baseWeeklyEmission * _circulatingSupplyAdjusted()) /\n            token.totalSupply();\n    }\n\n    /// @dev \n    function weeklyEmission() external view returns (uint) {\n        return _weeklyEmission();\n    }\n\n    function _weeklyEmission() internal view returns (uint) {\n        // Max(, )\n        return Math.max(_calculateEmission(), _circulatingEmission());\n    }\n\n    /// @dev  0.2%\n    function circulatingEmission() external view returns (uint) {\n        return _circulatingEmission();\n    }\n\n    /// @dev  =  * 1%\n    function _circulatingEmission() internal view returns (uint) {\n        return\n            (_circulatingSupply() * _TAIL_EMISSION) /\n            _TAIL_EMISSION_DENOMINATOR;\n    }\n\n    /// @dev  ve \n    function calculateGrowth(uint _minted) external view returns (uint) {\n        return _calculateGrowth(_minted);\n    }\n\n    /// @dev  = ve *  / token / 10\n    function _calculateGrowth(uint _minted) internal view returns (uint) {\n        return\n            (IUnderlying(address(ve)).totalSupply() * _minted) /\n            token.totalSupply() /\n            _GROWTH_DIVIDER;\n    }\n\n    /// @dev 1 \n    function updatePeriod() external override returns (uint) {\n        uint _period = activePeriod;\n        // \n        if (block.timestamp >= _period + _WEEK && initializer == address(0)) {\n            //  = \n            _period = (block.timestamp / _WEEK) * _WEEK;\n            // \n            activePeriod = _period;\n            // \n            uint _weekly = _weeklyEmission();\n            // \n            //  =  * 98%\n            baseWeeklyEmission =\n                (baseWeeklyEmission * _WEEKLY_EMISSION_DECREASE) /\n                _WEEKLY_EMISSION_DECREASE_DENOMINATOR;\n            // \n            //   >  * 1%\n            if (initialStubCirculation > _circulatingEmission()) {\n                //  =  * 99%\n                initialStubCirculation =\n                    (initialStubCirculation * _INITIAL_CIRCULATION_DECREASE) /\n                    _INITIAL_CIRCULATION_DECREASE_DENOMINATOR;\n            }\n\n            //  = \n            uint _growth = _calculateGrowth(_weekly);\n            //  =  + \n            uint _required = _growth + _weekly;\n            // \n            uint _balanceOf = token.balanceOf(address(this));\n            //  < \n            if (_balanceOf < _required) {\n                // \n                token.mint(address(this), _required - _balanceOf);\n            }\n\n            // veDist\n            IERC20(address(token)).safeTransfer(address(_veDist()), _growth);\n            //  veDist \n            _veDist().checkpointToken();\n            // \n            _veDist().checkpointTotalSupply();\n\n            // voter,\n            token.approve(address(_voter()), _weekly);\n            _voter().notifyRewardAmount(_weekly);\n\n            // \n            emit Mint(\n                msg.sender, // \n                _weekly, // \n                _growth, // \n                _circulatingSupply(), // \n                _circulatingEmission() // \n            );\n        }\n        return _period;\n    }\n}\n"
    },
    "contracts/test/ContractTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../base/core/VoltPair.sol\";\nimport \"../base/vote/Ve.sol\";\nimport \"../interface/IVeDist.sol\";\n\ncontract ContractTestHelper is IERC721Receiver {\n    using SafeERC20 for IERC20;\n    using Math for uint;\n\n    function pairCurrentTwice(\n        address pair,\n        address tokenIn,\n        uint amountIn\n    ) external returns (uint, uint) {\n        uint c0 = VoltPair(pair).current(tokenIn, amountIn);\n        VoltPair(pair).sync();\n        uint c1 = VoltPair(pair).current(tokenIn, amountIn);\n        return (c0, c1);\n    }\n\n    function hook(\n        address,\n        uint amount0,\n        uint amount1,\n        bytes calldata data\n    ) external {\n        address pair = abi.decode(data, (address));\n        (address token0, address token1) = VoltPair(pair).tokens();\n        if (amount0 != 0) {\n            IERC20(token0).safeTransfer(pair, amount0);\n        }\n        if (amount1 != 0) {\n            IERC20(token1).safeTransfer(pair, amount1);\n        }\n    }\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn,\n        uint reserveOut\n    ) public pure returns (uint amountOut) {\n        // without fee\n        uint amountInWithFee = amountIn * 1000;\n        uint numerator = amountInWithFee * reserveOut;\n        uint denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    function veFlashTransfer(address ve, uint tokenId) external {\n        Ve(ve).safeTransferFrom(msg.sender, address(this), tokenId);\n        require(Ve(ve).balanceOfNFT(tokenId) == 0, \"not zero balance\");\n        Ve(ve).tokenURI(tokenId);\n        Ve(ve).totalSupplyAt(block.number);\n        Ve(ve).checkpoint();\n        Ve(ve).checkpoint();\n        Ve(ve).checkpoint();\n        Ve(ve).checkpoint();\n        Ve(ve).totalSupplyAt(block.number);\n        Ve(ve).totalSupplyAt(block.number - 1);\n        Ve(ve).safeTransferFrom(address(this), msg.sender, tokenId);\n    }\n\n    function multipleVeDistCheckpoints(address veDist) external {\n        IVeDist(veDist).checkpointToken();\n        IVeDist(veDist).checkpointToken();\n        IVeDist(veDist).checkpointTotalSupply();\n        IVeDist(veDist).checkpointTotalSupply();\n    }\n\n    function closeTo(\n        uint a,\n        uint b,\n        uint target\n    ) external pure returns (bool) {\n        return a.closeTo(b, target);\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/base/reward/Gauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IGauge.sol\";\nimport \"../../interface/IPair.sol\";\nimport \"../../interface/IVoter.sol\";\nimport \"../../interface/IBribe.sol\";\nimport \"../../interface/IERC721.sol\";\nimport \"../../interface/IVe.sol\";\nimport \"./MultiRewardsPoolBase.sol\";\n\n/// @title Gauges are used to incentivize pools, they emit reward tokens over 7 days for staked LP tokens\ncontract Gauge is IGauge, MultiRewardsPoolBase {\n    using SafeERC20 for IERC20;\n\n    /// @dev The ve token used for gauges\n    address public ve;\n    address public bribe;\n    address public voter;\n\n    mapping(address => uint) public tokenIds;\n\n    uint public fees0;\n    uint public fees1;\n\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n    event VeTokenLocked(address indexed account, uint tokenId);\n    event VeTokenUnlocked(address indexed account, uint tokenId);\n\n    constructor(\n        address _stake,\n        address _bribe,\n        address _ve,\n        address _voter,\n        address[] memory _allowedRewardTokens\n    ) MultiRewardsPoolBase(_stake, _voter, _allowedRewardTokens) {\n        bribe = _bribe;\n        ve = _ve;\n        voter = _voter;\n    }\n\n    function claimFees()\n        external\n        override\n        lock\n        returns (uint claimed0, uint claimed1)\n    {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        address _underlying = underlying;\n        (claimed0, claimed1) = IPair(_underlying).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(_underlying).tokens();\n            if (_fees0 > IMultiRewardsPool(bribe).left(_token0)) {\n                fees0 = 0;\n                IERC20(_token0).safeIncreaseAllowance(bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 > IMultiRewardsPool(bribe).left(_token1)) {\n                fees1 = 0;\n                IERC20(_token1).safeIncreaseAllowance(bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function getReward(address account, address[] memory tokens)\n        external\n        override\n    {\n        require(msg.sender == account || msg.sender == voter, \"Forbidden\");\n        IVoter(voter).distribute(address(this));\n        _getReward(account, tokens, account);\n    }\n\n    function depositAll(uint tokenId) external {\n        deposit(IERC20(underlying).balanceOf(msg.sender), tokenId);\n    }\n\n    function deposit(uint amount, uint tokenId) public {\n        if (tokenId > 0) {\n            _lockVeToken(msg.sender, tokenId);\n        }\n        _deposit(amount);\n        IVoter(voter).emitDeposit(tokenId, msg.sender, amount);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf[msg.sender]);\n    }\n\n    function withdraw(uint amount) public {\n        uint tokenId = 0;\n        if (amount == balanceOf[msg.sender]) {\n            tokenId = tokenIds[msg.sender];\n        }\n        withdrawToken(amount, tokenId);\n        IVoter(voter).emitWithdraw(tokenId, msg.sender, amount);\n    }\n\n    function withdrawToken(uint amount, uint tokenId) public {\n        if (tokenId > 0) {\n            _unlockVeToken(msg.sender, tokenId);\n        }\n        _withdraw(amount);\n    }\n\n    /// @dev Balance should be recalculated after the lock\n    ///      For locking a new ve token withdraw all funds and deposit again\n    function _lockVeToken(address account, uint tokenId) internal {\n        require(IERC721(ve).ownerOf(tokenId) == account, \"Not ve token owner\");\n        if (tokenIds[account] == 0) {\n            tokenIds[account] = tokenId;\n            IVoter(voter).attachTokenToGauge(tokenId, account);\n        }\n        require(tokenIds[account] == tokenId, \"Wrong token\");\n        emit VeTokenLocked(account, tokenId);\n    }\n\n    /// @dev Balance should be recalculated after the unlock\n    function _unlockVeToken(address account, uint tokenId) internal {\n        require(tokenId == tokenIds[account], \"Wrong token\");\n        tokenIds[account] = 0;\n        IVoter(voter).detachTokenFromGauge(tokenId, account);\n        emit VeTokenUnlocked(account, tokenId);\n    }\n\n    /// @dev Similar to Curve https://resources.curve.fi/reward-gauges/boosting-your-crv-rewards#formula\n    function _derivedBalance(address account)\n        internal\n        view\n        override\n        returns (uint)\n    {\n        uint _tokenId = tokenIds[account];\n        uint _balance = balanceOf[account];\n        uint _derived = (_balance * 40) / 100;\n        uint _adjusted = 0;\n        uint _supply = IERC20(ve).totalSupply();\n        if (account == IERC721(ve).ownerOf(_tokenId) && _supply > 0) {\n            _adjusted =\n                (((totalSupply * IVe(ve).balanceOfNFT(_tokenId)) / _supply) *\n                    60) /\n                100;\n        }\n        return Math.min((_derived + _adjusted), _balance);\n    }\n\n    function notifyRewardAmount(address token, uint amount) external {\n        _claimFees();\n        _notifyRewardAmount(token, amount);\n    }\n}\n"
    },
    "contracts/base/reward/MultiRewardsPoolBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IMultiRewardsPool.sol\";\nimport \"../../lib/Math.sol\";\nimport \"../../lib/SafeERC20.sol\";\nimport \"../../lib/CheckpointLib.sol\";\nimport \"../Reentrancy.sol\";\n\nabstract contract MultiRewardsPoolBase is Reentrancy, IMultiRewardsPool {\n    using SafeERC20 for IERC20;\n    using CheckpointLib for mapping(uint => CheckpointLib.Checkpoint);\n\n    /// @dev Operator can add/remove reward tokens\n    address public operator;\n\n    /// @dev The LP token that needs to be staked for rewards\n    address public immutable override underlying;\n\n    uint public override derivedSupply;\n    mapping(address => uint) public override derivedBalances;\n\n    /// @dev Rewards are released over 7 days\n    uint internal constant DURATION = 7 days;\n    uint internal constant PRECISION = 10**18;\n    uint internal constant MAX_REWARD_TOKENS = 10;\n\n    /// Default snx staking contract implementation\n    /// https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol\n\n    /// @dev Reward rate with precision 1e18\n    mapping(address => uint) public rewardRate;\n    mapping(address => uint) public periodFinish;\n    mapping(address => uint) public lastUpdateTime;\n    mapping(address => uint) public rewardPerTokenStored;\n\n    mapping(address => mapping(address => uint)) public lastEarn;\n    mapping(address => mapping(address => uint))\n        public userRewardPerTokenStored;\n\n    uint public override totalSupply;\n    mapping(address => uint) public override balanceOf;\n\n    address[] public override rewardTokens;\n    mapping(address => bool) public override isRewardToken;\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping(address => mapping(uint => CheckpointLib.Checkpoint))\n        public checkpoints;\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping(uint => CheckpointLib.Checkpoint) public supplyCheckpoints;\n    /// @notice The number of checkpoints\n    uint public supplyNumCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping(address => mapping(uint => CheckpointLib.Checkpoint))\n        public rewardPerTokenCheckpoints;\n    /// @notice The number of checkpoints for each token\n    mapping(address => uint) public rewardPerTokenNumCheckpoints;\n\n    event Deposit(address indexed from, uint amount);\n    event Withdraw(address indexed from, uint amount);\n    event NotifyReward(\n        address indexed from,\n        address indexed reward,\n        uint amount\n    );\n    event ClaimRewards(\n        address indexed from,\n        address indexed reward,\n        uint amount,\n        address recepient\n    );\n\n    constructor(\n        address _stake,\n        address _operator,\n        address[] memory _allowedRewardTokens\n    ) {\n        underlying = _stake;\n        operator = _operator;\n        for (uint i; i < _allowedRewardTokens.length; i++) {\n            if (_allowedRewardTokens[i] != address(0)) {\n                _registerRewardToken(_allowedRewardTokens[i]);\n            }\n        }\n    }\n\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"Not operator\");\n        _;\n    }\n\n    //**************************************************************************\n    //************************ VIEWS *******************************************\n    //**************************************************************************\n\n    function rewardTokensLength() external view override returns (uint) {\n        return rewardTokens.length;\n    }\n\n    function rewardPerToken(address token) external view returns (uint) {\n        return _rewardPerToken(token);\n    }\n\n    function _rewardPerToken(address token) internal view returns (uint) {\n        if (derivedSupply == 0) {\n            return rewardPerTokenStored[token];\n        }\n        return\n            rewardPerTokenStored[token] +\n            (((_lastTimeRewardApplicable(token) -\n                Math.min(lastUpdateTime[token], periodFinish[token])) *\n                rewardRate[token]) / derivedSupply);\n    }\n\n    function derivedBalance(address account)\n        external\n        view\n        override\n        returns (uint)\n    {\n        return _derivedBalance(account);\n    }\n\n    function left(address token) external view override returns (uint) {\n        if (block.timestamp >= periodFinish[token]) return 0;\n        uint _remaining = periodFinish[token] - block.timestamp;\n        return (_remaining * rewardRate[token]) / PRECISION;\n    }\n\n    function earned(address token, address account)\n        external\n        view\n        override\n        returns (uint)\n    {\n        return _earned(token, account);\n    }\n\n    //**************************************************************************\n    //************************ OPERATOR ACTIONS ********************************\n    //**************************************************************************\n\n    function registerRewardToken(address token) external onlyOperator {\n        _registerRewardToken(token);\n    }\n\n    function _registerRewardToken(address token) internal {\n        require(\n            rewardTokens.length < MAX_REWARD_TOKENS,\n            \"Too many reward tokens\"\n        );\n        require(!isRewardToken[token], \"Already registered\");\n        isRewardToken[token] = true;\n        rewardTokens.push(token);\n    }\n\n    function removeRewardToken(address token) external onlyOperator {\n        require(periodFinish[token] < block.timestamp, \"Rewards not ended\");\n        require(isRewardToken[token], \"Not reward token\");\n\n        isRewardToken[token] = false;\n        uint length = rewardTokens.length;\n        require(length > 3, \"First 3 tokens should not be removed\");\n        // keep 3 tokens as guarantee against malicious actions\n        // assume it will be VOLT + pool tokens\n        uint i = 3;\n        bool found = false;\n        for (; i < length; i++) {\n            address t = rewardTokens[i];\n            if (t == token) {\n                found = true;\n                break;\n            }\n        }\n        require(found, \"First tokens forbidden to remove\");\n        rewardTokens[i] = rewardTokens[length - 1];\n        rewardTokens.pop();\n    }\n\n    //**************************************************************************\n    //************************ USER ACTIONS ************************************\n    //**************************************************************************\n\n    function _deposit(uint amount) internal virtual lock {\n        require(amount > 0, \"Zero amount\");\n        _increaseBalance(msg.sender, amount);\n        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\n        emit Deposit(msg.sender, amount);\n    }\n\n    function _increaseBalance(address account, uint amount) internal virtual {\n        _updateRewardForAllTokens();\n\n        totalSupply += amount;\n        balanceOf[account] += amount;\n\n        _updateDerivedBalanceAndWriteCheckpoints(account);\n    }\n\n    function _withdraw(uint amount) internal virtual lock {\n        _decreaseBalance(msg.sender, amount);\n        IERC20(underlying).safeTransfer(msg.sender, amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function _decreaseBalance(address account, uint amount) internal virtual {\n        _updateRewardForAllTokens();\n\n        totalSupply -= amount;\n        balanceOf[account] -= amount;\n\n        _updateDerivedBalanceAndWriteCheckpoints(account);\n    }\n\n    /// @dev Implement restriction checks!\n    function _getReward(\n        address account,\n        address[] memory tokens,\n        address recipient\n    ) internal virtual lock {\n        for (uint i = 0; i < tokens.length; i++) {\n            (\n                rewardPerTokenStored[tokens[i]],\n                lastUpdateTime[tokens[i]]\n            ) = _updateRewardPerToken(tokens[i], type(uint).max, true);\n\n            uint _reward = _earned(tokens[i], account);\n            lastEarn[tokens[i]][account] = block.timestamp;\n            userRewardPerTokenStored[tokens[i]][account] = rewardPerTokenStored[\n                tokens[i]\n            ];\n            if (_reward > 0) {\n                IERC20(tokens[i]).safeTransfer(recipient, _reward);\n            }\n\n            emit ClaimRewards(msg.sender, tokens[i], _reward, recipient);\n        }\n\n        _updateDerivedBalanceAndWriteCheckpoints(account);\n    }\n\n    function _updateDerivedBalanceAndWriteCheckpoints(address account)\n        internal\n    {\n        uint __derivedBalance = derivedBalances[account];\n        derivedSupply -= __derivedBalance;\n        __derivedBalance = _derivedBalance(account);\n        derivedBalances[account] = __derivedBalance;\n        derivedSupply += __derivedBalance;\n\n        _writeCheckpoint(account, __derivedBalance);\n        _writeSupplyCheckpoint();\n    }\n\n    //**************************************************************************\n    //************************ REWARDS CALCULATIONS ****************************\n    //**************************************************************************\n\n    // earned is an estimation, it won't be exact till the supply > rewardPerToken calculations have run\n    function _earned(address token, address account)\n        internal\n        view\n        returns (uint)\n    {\n        // zero checkpoints means zero deposits\n        if (numCheckpoints[account] == 0) {\n            return 0;\n        }\n        // last claim rewards time\n        uint _startTimestamp = Math.max(\n            lastEarn[token][account],\n            rewardPerTokenCheckpoints[token][0].timestamp\n        );\n\n        // find an index of the balance that the user had on the last claim\n        uint _startIndex = _getPriorBalanceIndex(account, _startTimestamp);\n        uint _endIndex = numCheckpoints[account] - 1;\n\n        uint reward = 0;\n\n        // calculate previous snapshots if exist\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i <= _endIndex - 1; i++) {\n                CheckpointLib.Checkpoint memory cp0 = checkpoints[account][i];\n                CheckpointLib.Checkpoint memory cp1 = checkpoints[account][\n                    i + 1\n                ];\n                (uint _rewardPerTokenStored0, ) = _getPriorRewardPerToken(\n                    token,\n                    cp0.timestamp\n                );\n                (uint _rewardPerTokenStored1, ) = _getPriorRewardPerToken(\n                    token,\n                    cp1.timestamp\n                );\n                reward +=\n                    (cp0.value *\n                        (_rewardPerTokenStored1 - _rewardPerTokenStored0)) /\n                    PRECISION;\n            }\n        }\n\n        CheckpointLib.Checkpoint memory cp = checkpoints[account][_endIndex];\n        (uint _rewardPerTokenStored, ) = _getPriorRewardPerToken(\n            token,\n            cp.timestamp\n        );\n        reward +=\n            (cp.value *\n                (_rewardPerToken(token) -\n                    Math.max(\n                        _rewardPerTokenStored,\n                        userRewardPerTokenStored[token][account]\n                    ))) /\n            PRECISION;\n        return reward;\n    }\n\n    function _derivedBalance(address account)\n        internal\n        view\n        virtual\n        returns (uint)\n    {\n        // supposed to be implemented in a parent contract\n        return balanceOf[account];\n    }\n\n    /// @dev Update stored rewardPerToken values without the last one snapshot\n    ///      If the contract will get \"out of gas\" error on users actions this will be helpful\n    function batchUpdateRewardPerToken(address token, uint maxRuns) external {\n        (\n            rewardPerTokenStored[token],\n            lastUpdateTime[token]\n        ) = _updateRewardPerToken(token, maxRuns, false);\n    }\n\n    function _updateRewardForAllTokens() internal {\n        uint length = rewardTokens.length;\n        for (uint i; i < length; i++) {\n            address token = rewardTokens[i];\n            (\n                rewardPerTokenStored[token],\n                lastUpdateTime[token]\n            ) = _updateRewardPerToken(token, type(uint).max, true);\n        }\n    }\n\n    /// @dev Should be called only with properly updated snapshots, or with actualLast=false\n    function _updateRewardPerToken(\n        address token,\n        uint maxRuns,\n        bool actualLast\n    ) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n        uint _startIndex = _getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = Math.min(supplyNumCheckpoints - 1, maxRuns);\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i <= _endIndex - 1; i++) {\n                CheckpointLib.Checkpoint memory sp0 = supplyCheckpoints[i];\n                if (sp0.value > 0) {\n                    CheckpointLib.Checkpoint memory sp1 = supplyCheckpoints[\n                        i + 1\n                    ];\n                    (uint _reward, uint _endTime) = _calcRewardPerToken(\n                        token,\n                        sp1.timestamp,\n                        sp0.timestamp,\n                        sp0.value,\n                        _startTimestamp\n                    );\n                    reward += _reward;\n                    _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                    _startTimestamp = _endTime;\n                }\n            }\n        }\n\n        // need to override the last value with actual numbers only on deposit/withdraw/claim/notify actions\n        if (actualLast) {\n            CheckpointLib.Checkpoint memory sp = supplyCheckpoints[_endIndex];\n            if (sp.value > 0) {\n                (uint _reward, ) = _calcRewardPerToken(\n                    token,\n                    _lastTimeRewardApplicable(token),\n                    Math.max(sp.timestamp, _startTimestamp),\n                    sp.value,\n                    _startTimestamp\n                );\n                reward += _reward;\n                _writeRewardPerTokenCheckpoint(token, reward, block.timestamp);\n                _startTimestamp = block.timestamp;\n            }\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    function _calcRewardPerToken(\n        address token,\n        uint lastSupplyTs1,\n        uint lastSupplyTs0,\n        uint supply,\n        uint startTimestamp\n    ) internal view returns (uint, uint) {\n        uint endTime = Math.max(lastSupplyTs1, startTimestamp);\n        uint _periodFinish = periodFinish[token];\n        return (\n            ((Math.min(endTime, _periodFinish) -\n                Math.min(\n                    Math.max(lastSupplyTs0, startTimestamp),\n                    _periodFinish\n                )) * rewardRate[token]) / supply,\n            endTime\n        );\n    }\n\n    /// @dev Returns the last time the reward was modified or periodFinish if the reward has ended\n    function _lastTimeRewardApplicable(address token)\n        internal\n        view\n        returns (uint)\n    {\n        return Math.min(block.timestamp, periodFinish[token]);\n    }\n\n    //**************************************************************************\n    //************************ NOTIFY ******************************************\n    //**************************************************************************\n\n    function _notifyRewardAmount(address token, uint amount)\n        internal\n        virtual\n        lock\n    {\n        require(token != underlying, \"Wrong token for rewards\");\n        require(amount > 0, \"Zero amount\");\n        require(isRewardToken[token], \"Token not allowed\");\n        if (rewardRate[token] == 0) {\n            _writeRewardPerTokenCheckpoint(token, 0, block.timestamp);\n        }\n        (\n            rewardPerTokenStored[token],\n            lastUpdateTime[token]\n        ) = _updateRewardPerToken(token, type(uint).max, true);\n\n        if (block.timestamp >= periodFinish[token]) {\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n            rewardRate[token] = (amount * PRECISION) / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            // not sure what the reason was in the original solidly implementation for this restriction\n            // however, by design probably it is a good idea against human errors\n            require(\n                amount > _left / PRECISION,\n                \"Amount should be higher than remaining rewards\"\n            );\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n            rewardRate[token] = (amount * PRECISION + _left) / DURATION;\n        }\n\n        periodFinish[token] = block.timestamp + DURATION;\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    //**************************************************************************\n    //************************ CHECKPOINTS *************************************\n    //**************************************************************************\n\n    function getPriorBalanceIndex(address account, uint timestamp)\n        external\n        view\n        returns (uint)\n    {\n        return _getPriorBalanceIndex(account, timestamp);\n    }\n\n    /// @notice Determine the prior balance for an account as of a block number\n    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    /// @param account The address of the account to check\n    /// @param timestamp The timestamp to get the balance at\n    /// @return The balance the account had as of the given block\n    function _getPriorBalanceIndex(address account, uint timestamp)\n        internal\n        view\n        returns (uint)\n    {\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n        return checkpoints[account].findLowerIndex(nCheckpoints, timestamp);\n    }\n\n    function getPriorSupplyIndex(uint timestamp) external view returns (uint) {\n        return _getPriorSupplyIndex(timestamp);\n    }\n\n    function _getPriorSupplyIndex(uint timestamp) internal view returns (uint) {\n        uint nCheckpoints = supplyNumCheckpoints;\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n        return supplyCheckpoints.findLowerIndex(nCheckpoints, timestamp);\n    }\n\n    function getPriorRewardPerToken(address token, uint timestamp)\n        external\n        view\n        returns (uint, uint)\n    {\n        return _getPriorRewardPerToken(token, timestamp);\n    }\n\n    function _getPriorRewardPerToken(address token, uint timestamp)\n        internal\n        view\n        returns (uint, uint)\n    {\n        uint nCheckpoints = rewardPerTokenNumCheckpoints[token];\n        if (nCheckpoints == 0) {\n            return (0, 0);\n        }\n        mapping(uint => CheckpointLib.Checkpoint)\n            storage cps = rewardPerTokenCheckpoints[token];\n        uint lower = cps.findLowerIndex(nCheckpoints, timestamp);\n        CheckpointLib.Checkpoint memory cp = cps[lower];\n        return (cp.value, cp.timestamp);\n    }\n\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (\n            _nCheckPoints > 0 &&\n            checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp\n        ) {\n            checkpoints[account][_nCheckPoints - 1].value = balance;\n        } else {\n            checkpoints[account][_nCheckPoints] = CheckpointLib.Checkpoint(\n                _timestamp,\n                balance\n            );\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeRewardPerTokenCheckpoint(\n        address token,\n        uint reward,\n        uint timestamp\n    ) internal {\n        uint _nCheckPoints = rewardPerTokenNumCheckpoints[token];\n\n        if (\n            _nCheckPoints > 0 &&\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].timestamp ==\n            timestamp\n        ) {\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].value = reward;\n        } else {\n            rewardPerTokenCheckpoints[token][_nCheckPoints] = CheckpointLib\n                .Checkpoint(timestamp, reward);\n            rewardPerTokenNumCheckpoints[token] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeSupplyCheckpoint() internal {\n        uint _nCheckPoints = supplyNumCheckpoints;\n        uint _timestamp = block.timestamp;\n\n        if (\n            _nCheckPoints > 0 &&\n            supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp\n        ) {\n            supplyCheckpoints[_nCheckPoints - 1].value = derivedSupply;\n        } else {\n            supplyCheckpoints[_nCheckPoints] = CheckpointLib.Checkpoint(\n                _timestamp,\n                derivedSupply\n            );\n            supplyNumCheckpoints = _nCheckPoints + 1;\n        }\n    }\n}\n"
    },
    "contracts/base/reward/GaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IGaugeFactory.sol\";\nimport \"./Gauge.sol\";\n\ncontract GaugeFactory is IGaugeFactory {\n    address public lastGauge;\n\n    event GaugeCreated(address value);\n\n    function createGauge(\n        address _pool,\n        address _bribe,\n        address _ve,\n        address[] memory _allowedRewardTokens\n    ) external override returns (address) {\n        address _lastGauge = address(\n            new Gauge(_pool, _bribe, _ve, msg.sender, _allowedRewardTokens)\n        );\n        lastGauge = _lastGauge;\n        emit GaugeCreated(_lastGauge);\n        return _lastGauge;\n    }\n\n    function createGaugeSingle(\n        address _pool,\n        address _bribe,\n        address _ve,\n        address _voter,\n        address[] memory _allowedRewardTokens\n    ) external override returns (address) {\n        address _lastGauge = address(\n            new Gauge(_pool, _bribe, _ve, _voter, _allowedRewardTokens)\n        );\n        lastGauge = _lastGauge;\n        emit GaugeCreated(_lastGauge);\n        return _lastGauge;\n    }\n}\n"
    },
    "contracts/test/MultiRewardsPoolMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../base/reward/MultiRewardsPoolBase.sol\";\n\ncontract MultiRewardsPoolMock is MultiRewardsPoolBase {\n    constructor(\n        address _stake,\n        address _operator,\n        address[] memory _rewards\n    ) MultiRewardsPoolBase(_stake, _operator, _rewards) {}\n\n    // for test 2 deposits in one tx\n    function testDoubleDeposit(uint amount) external {\n        uint amount0 = amount / 2;\n        uint amount1 = amount - amount0;\n        _deposit(amount0);\n        _deposit(amount1);\n    }\n\n    // for test 2 withdraws in one tx\n    function testDoubleWithdraw(uint amount) external {\n        uint amount0 = amount / 2;\n        uint amount1 = amount - amount0;\n        _withdraw(amount0);\n        _withdraw(amount1);\n    }\n\n    function deposit(uint amount) external {\n        _deposit(amount);\n    }\n\n    function withdraw(uint amount) external {\n        _withdraw(amount);\n    }\n\n    function getReward(address account, address[] memory tokens) external {\n        require(msg.sender == account, \"Forbidden\");\n        _getReward(account, tokens, account);\n    }\n\n    function notifyRewardAmount(address token, uint amount) external {\n        _notifyRewardAmount(token, amount);\n    }\n}\n"
    },
    "contracts/base/reward/Bribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IBribe.sol\";\nimport \"../../interface/IERC721.sol\";\nimport \"../../interface/IVoter.sol\";\nimport \"../../interface/IVe.sol\";\nimport \"./MultiRewardsPoolBase.sol\";\n\n/// @title Bribes pay out rewards for a given pool based on the votes\n///        that were received from the user (goes hand in hand with Gauges.vote())\ncontract Bribe is IBribe, MultiRewardsPoolBase {\n    /// @dev Only voter can modify balances (since it only happens on vote())\n    address public voter;\n    address public ve;\n\n    // Assume that will be created from voter contract through factory\n    constructor(address _voter, address[] memory _allowedRewardTokens)\n        MultiRewardsPoolBase(address(0), _voter, _allowedRewardTokens)\n    {\n        voter = _voter;\n        ve = IVoter(_voter).ve();\n    }\n\n    function getReward(uint tokenId, address[] memory tokens) external {\n        require(\n            IVe(ve).isApprovedOrOwner(msg.sender, tokenId),\n            \"Not token owner\"\n        );\n        _getReward(_tokenIdToAddress(tokenId), tokens, msg.sender);\n    }\n\n    /// @dev Used by Voter to allow batched reward claims\n    function getRewardForOwner(uint tokenId, address[] memory tokens)\n        external\n        override\n    {\n        require(msg.sender == voter, \"Not voter\");\n        address owner = IERC721(ve).ownerOf(tokenId);\n        _getReward(_tokenIdToAddress(tokenId), tokens, owner);\n    }\n\n    /// @dev This is an external function, but internal notation is used\n    ///      since it can only be called \"internally\" from Gauges\n    function _deposit(uint amount, uint tokenId) external override {\n        require(msg.sender == voter, \"Not voter\");\n        require(amount > 0, \"Zero amount\");\n\n        address adr = _tokenIdToAddress(tokenId);\n        _increaseBalance(adr, amount);\n        emit Deposit(adr, amount);\n    }\n\n    function _withdraw(uint amount, uint tokenId) external override {\n        require(msg.sender == voter, \"Not voter\");\n        require(amount > 0, \"Zero amount\");\n\n        address adr = _tokenIdToAddress(tokenId);\n        _decreaseBalance(adr, amount);\n        emit Withdraw(adr, amount);\n    }\n\n    /// @dev Used to notify a gauge/bribe of a given reward,\n    ///      this can create griefing attacks by extending rewards\n    function notifyRewardAmount(address token, uint amount) external override {\n        _notifyRewardAmount(token, amount);\n    }\n\n    // use tokenId instead of address for\n\n    function tokenIdToAddress(uint tokenId) external pure returns (address) {\n        return _tokenIdToAddress(tokenId);\n    }\n\n    function _tokenIdToAddress(uint tokenId) internal pure returns (address) {\n        address adr = address(uint160(tokenId));\n        require(_addressToTokenId(adr) == tokenId, \"Wrong convert\");\n        return adr;\n    }\n\n    function addressToTokenId(address adr) external pure returns (uint) {\n        return _addressToTokenId(adr);\n    }\n\n    function _addressToTokenId(address adr) internal pure returns (uint) {\n        return uint(uint160(adr));\n    }\n}\n"
    },
    "contracts/base/reward/BribeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./Bribe.sol\";\nimport \"../../interface/IBribeFactory.sol\";\n\ncontract BribeFactory is IBribeFactory {\n    address public lastGauge;\n\n    event BribeCreated(address value);\n\n    function createBribe(address[] memory _allowedRewardTokens)\n        external\n        override\n        returns (address)\n    {\n        address _lastGauge = address(\n            new Bribe(msg.sender, _allowedRewardTokens)\n        );\n        lastGauge = _lastGauge;\n        emit BribeCreated(_lastGauge);\n        return _lastGauge;\n    }\n}\n"
    },
    "contracts/lib/SolidlyLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\nimport \"../interface/IPair.sol\";\nimport \"../interface/IRouter.sol\";\n\ncontract SolidlyLibrary {\n    IRouter internal router;\n\n    constructor(address _router) {\n        router = IRouter(_router);\n    }\n\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return\n            (x0 * ((((y * y) / 1e18) * y) / 1e18)) /\n            1e18 +\n            (((((x0 * x0) / 1e18) * x0) / 1e18) * y) /\n            1e18;\n    }\n\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return\n            (3 * x0 * ((y * y) / 1e18)) /\n            1e18 +\n            ((((x0 * x0) / 1e18) * x0) / 1e18);\n    }\n\n    function _get_y(\n        uint256 x0,\n        uint256 xy,\n        uint256 y\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 y_prev = y;\n            uint256 k = _f(x0, y);\n            if (k < xy) {\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\n                y = y + dy;\n            } else {\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\n                y = y - dy;\n            }\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    return y;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    return y;\n                }\n            }\n        }\n        return y;\n    }\n\n    function getTradeDiff(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint256 a, uint256 b) {\n        (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n\n        ) = IPair(router.pairFor(tokenIn, tokenOut, stable)).metadata();\n        uint256 sample = tokenIn == t0 ? (r0 * dec1) / r1 : (r1 * dec0) / r0;\n        a =\n            (_getAmountOut(sample, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) /\n            sample;\n        b =\n            (_getAmountOut(amountIn, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) /\n            amountIn;\n    }\n\n    function getTradeDiff(\n        uint256 amountIn,\n        address tokenIn,\n        address pair\n    ) external view returns (uint256 a, uint256 b) {\n        (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n\n        ) = IPair(pair).metadata();\n        uint256 sample = tokenIn == t0 ? (r0 * dec1) / r1 : (r1 * dec0) / r0;\n        a =\n            (_getAmountOut(sample, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) /\n            sample;\n        b =\n            (_getAmountOut(amountIn, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) /\n            amountIn;\n    }\n\n    function getSample(\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint256) {\n        (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n\n        ) = IPair(router.pairFor(tokenIn, tokenOut, stable)).metadata();\n        uint256 sample = tokenIn == t0 ? (r0 * dec1) / r1 : (r1 * dec0) / r0;\n        return\n            (_getAmountOut(sample, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) / sample;\n    }\n\n    function getMinimumValue(\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            ,\n            address t0,\n\n        ) = IPair(router.pairFor(tokenIn, tokenOut, stable)).metadata();\n        uint256 sample = tokenIn == t0 ? (r0 * dec1) / r1 : (r1 * dec0) / r0;\n        return (sample, r0, r1);\n    }\n\n    function getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint256) {\n        (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n\n        ) = IPair(router.pairFor(tokenIn, tokenOut, stable)).metadata();\n        return\n            (_getAmountOut(amountIn, tokenIn, r0, r1, t0, dec0, dec1, st) *\n                1e18) / amountIn;\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        uint256 _reserve0,\n        uint256 _reserve1,\n        address token0,\n        uint256 decimals0,\n        uint256 decimals1,\n        bool stable\n    ) internal pure returns (uint256) {\n        if (stable) {\n            uint256 xy = _k(_reserve0, _reserve1, stable, decimals0, decimals1);\n            _reserve0 = (_reserve0 * 1e18) / decimals0;\n            _reserve1 = (_reserve1 * 1e18) / decimals1;\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            amountIn = tokenIn == token0\n                ? (amountIn * 1e18) / decimals0\n                : (amountIn * 1e18) / decimals1;\n            uint256 y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\n            return (y * (tokenIn == token0 ? decimals1 : decimals0)) / 1e18;\n        } else {\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            return (amountIn * reserveB) / (reserveA + amountIn);\n        }\n    }\n\n    function _k(\n        uint256 x,\n        uint256 y,\n        bool stable,\n        uint256 decimals0,\n        uint256 decimals1\n    ) internal pure returns (uint256) {\n        if (stable) {\n            uint256 _x = (x * 1e18) / decimals0;\n            uint256 _y = (y * 1e18) / decimals1;\n            uint256 _a = (_x * _y) / 1e18;\n            uint256 _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n            return (_a * _b) / 1e18; // x3y+y3x >= k\n        } else {\n            return x * y; // xy >= k\n        }\n    }\n}\n"
    },
    "contracts/base/periphery/VoltRouter01.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../lib/Math.sol\";\nimport \"../../lib/SafeERC20.sol\";\nimport \"../../interface/IERC20.sol\";\nimport \"../../interface/IWMTR.sol\";\nimport \"../../interface/IPair.sol\";\nimport \"../../interface/IFactory.sol\";\n\ncontract VoltRouter01 {\n    using SafeERC20 for IERC20;\n\n    struct Route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    address public immutable factory;\n    IWMTR public immutable wmtr;\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\n    bytes32 immutable pairCodeHash;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, \"VoltRouter: EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _wmtr) {\n        factory = _factory;\n        pairCodeHash = IFactory(_factory).pairCodeHash();\n        wmtr = IWMTR(_wmtr);\n    }\n\n    receive() external payable {\n        // only accept ETH via fallback from the WETH contract\n        require(msg.sender == address(wmtr), \"VoltRouter: NOT_WMTR\");\n    }\n\n    function sortTokens(address tokenA, address tokenB)\n        external\n        pure\n        returns (address token0, address token1)\n    {\n        return _sortTokens(tokenA, tokenB);\n    }\n\n    function _sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"VoltRouter: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"VoltRouter: ZERO_ADDRESS\");\n    }\n\n    function pairFor(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (address pair) {\n        return _pairFor(tokenA, tokenB, stable);\n    }\n\n    /// @dev Calculates the CREATE2 address for a pair without making any external calls.\n    function _pairFor(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) internal view returns (address pair) {\n        (address token0, address token1) = _sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1, stable)),\n                            pairCodeHash // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function quoteLiquidity(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) external pure returns (uint amountB) {\n        return _quoteLiquidity(amountA, reserveA, reserveB);\n    }\n\n    /// @dev Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset.\n    function _quoteLiquidity(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) internal pure returns (uint amountB) {\n        require(amountA > 0, \"VoltRouter: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"VoltRouter: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = (amountA * reserveB) / reserveA;\n    }\n\n    function getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (uint reserveA, uint reserveB) {\n        return _getReserves(tokenA, tokenB, stable);\n    }\n\n    /// @dev Fetches and sorts the reserves for a pair.\n    function _getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) internal view returns (uint reserveA, uint reserveB) {\n        (address token0, ) = _sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1, ) = IPair(\n            _pairFor(tokenA, tokenB, stable)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    /// @dev Performs chained getAmountOut calculations on any number of pairs.\n    function getAmountOut(\n        uint amountIn,\n        address tokenIn,\n        address tokenOut\n    ) external view returns (uint amount, bool stable) {\n        address pair = _pairFor(tokenIn, tokenOut, true);\n        uint amountStable;\n        uint amountVolatile;\n        if (IFactory(factory).isPair(pair)) {\n            amountStable = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        pair = _pairFor(tokenIn, tokenOut, false);\n        if (IFactory(factory).isPair(pair)) {\n            amountVolatile = IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return\n            amountStable > amountVolatile\n                ? (amountStable, true)\n                : (amountVolatile, false);\n    }\n\n    function getExactAmountOut(\n        uint amountIn,\n        address tokenIn,\n        address tokenOut,\n        bool stable\n    ) external view returns (uint) {\n        address pair = _pairFor(tokenIn, tokenOut, stable);\n        if (IFactory(factory).isPair(pair)) {\n            return IPair(pair).getAmountOut(amountIn, tokenIn);\n        }\n        return 0;\n    }\n\n    /// @dev Performs chained getAmountOut calculations on any number of pairs.\n    function getAmountsOut(uint amountIn, Route[] memory routes)\n        external\n        view\n        returns (uint[] memory amounts)\n    {\n        return _getAmountsOut(amountIn, routes);\n    }\n\n    function _getAmountsOut(uint amountIn, Route[] memory routes)\n        internal\n        view\n        returns (uint[] memory amounts)\n    {\n        require(routes.length >= 1, \"VoltRouter: INVALID_PATH\");\n        amounts = new uint[](routes.length + 1);\n        amounts[0] = amountIn;\n        for (uint i = 0; i < routes.length; i++) {\n            address pair = _pairFor(\n                routes[i].from,\n                routes[i].to,\n                routes[i].stable\n            );\n            if (IFactory(factory).isPair(pair)) {\n                amounts[i + 1] = IPair(pair).getAmountOut(\n                    amounts[i],\n                    routes[i].from\n                );\n            }\n        }\n    }\n\n    function isPair(address pair) external view returns (bool) {\n        return IFactory(factory).isPair(pair);\n    }\n\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired\n    )\n        external\n        view\n        returns (\n            uint amountA,\n            uint amountB,\n            uint liquidity\n        )\n    {\n        // create the pair if it doesn't exist yet\n        address _pair = IFactory(factory).getPair(tokenA, tokenB, stable);\n        (uint reserveA, uint reserveB) = (0, 0);\n        uint _totalSupply = 0;\n        if (_pair != address(0)) {\n            _totalSupply = IERC20(_pair).totalSupply();\n            (reserveA, reserveB) = _getReserves(tokenA, tokenB, stable);\n        }\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\n        } else {\n            uint amountBOptimal = _quoteLiquidity(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= amountBDesired) {\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n                liquidity = Math.min(\n                    (amountA * _totalSupply) / reserveA,\n                    (amountB * _totalSupply) / reserveB\n                );\n            } else {\n                uint amountAOptimal = _quoteLiquidity(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n                liquidity = Math.min(\n                    (amountA * _totalSupply) / reserveA,\n                    (amountB * _totalSupply) / reserveB\n                );\n            }\n        }\n    }\n\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity\n    ) external view returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        address _pair = IFactory(factory).getPair(tokenA, tokenB, stable);\n\n        if (_pair == address(0)) {\n            return (0, 0);\n        }\n\n        (uint reserveA, uint reserveB) = _getReserves(tokenA, tokenB, stable);\n        uint _totalSupply = IERC20(_pair).totalSupply();\n        // using balances ensures pro-rata distribution\n        amountA = (liquidity * reserveA) / _totalSupply;\n        // using balances ensures pro-rata distribution\n        amountB = (liquidity * reserveB) / _totalSupply;\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal returns (uint amountA, uint amountB) {\n        require(amountADesired >= amountAMin, \"VoltRouter: DESIRED_A_AMOUNT\");\n        require(amountBDesired >= amountBMin, \"VoltRouter: DESIRED_B_AMOUNT\");\n        // create the pair if it doesn't exist yet\n        address _pair = IFactory(factory).getPair(tokenA, tokenB, stable);\n        if (_pair == address(0)) {\n            _pair = IFactory(factory).createPair(tokenA, tokenB, stable);\n        }\n        (uint reserveA, uint reserveB) = _getReserves(tokenA, tokenB, stable);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = _quoteLiquidity(\n                amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= amountBDesired) {\n                require(\n                    amountBOptimal >= amountBMin,\n                    \"VoltRouter: INSUFFICIENT_B_AMOUNT\"\n                );\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = _quoteLiquidity(\n                    amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= amountADesired);\n                require(\n                    amountAOptimal >= amountAMin,\n                    \"VoltRouter: INSUFFICIENT_A_AMOUNT\"\n                );\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    )\n        external\n        ensure(deadline)\n        returns (\n            uint amountA,\n            uint amountB,\n            uint liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin\n        );\n        address pair = _pairFor(tokenA, tokenB, stable);\n        SafeERC20.safeTransferFrom(IERC20(tokenA), msg.sender, pair, amountA);\n        SafeERC20.safeTransferFrom(IERC20(tokenB), msg.sender, pair, amountB);\n        liquidity = IPair(pair).mint(to);\n    }\n\n    function addLiquidityMTR(\n        address token,\n        bool stable,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        ensure(deadline)\n        returns (\n            uint amountToken,\n            uint amountMTR,\n            uint liquidity\n        )\n    {\n        (amountToken, amountMTR) = _addLiquidity(\n            token,\n            address(wmtr),\n            stable,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountMTRMin\n        );\n        address pair = _pairFor(token, address(wmtr), stable);\n        IERC20(token).safeTransferFrom(msg.sender, pair, amountToken);\n        wmtr.deposit{value: amountMTR}();\n        assert(wmtr.transfer(pair, amountMTR));\n        liquidity = IPair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountMTR)\n            _safeTransferMTR(msg.sender, msg.value - amountMTR);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB) {\n        return\n            _removeLiquidity(\n                tokenA,\n                tokenB,\n                stable,\n                liquidity,\n                amountAMin,\n                amountBMin,\n                to,\n                deadline\n            );\n    }\n\n    function _removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) internal ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = _pairFor(tokenA, tokenB, stable);\n        IERC20(pair).safeTransferFrom(msg.sender, pair, liquidity);\n        // send liquidity to pair\n        (uint amount0, uint amount1) = IPair(pair).burn(to);\n        (address token0, ) = _sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n        require(amountA >= amountAMin, \"VoltRouter: INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= amountBMin, \"VoltRouter: INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidityMTR(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountMTR) {\n        return\n            _removeLiquidityMTR(\n                token,\n                stable,\n                liquidity,\n                amountTokenMin,\n                amountMTRMin,\n                to,\n                deadline\n            );\n    }\n\n    function _removeLiquidityMTR(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline\n    ) internal ensure(deadline) returns (uint amountToken, uint amountMTR) {\n        (amountToken, amountMTR) = _removeLiquidity(\n            token,\n            address(wmtr),\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountMTRMin,\n            address(this),\n            deadline\n        );\n        IERC20(token).safeTransfer(to, amountToken);\n        wmtr.withdraw(amountMTR);\n        _safeTransferMTR(to, amountMTR);\n    }\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountA, uint amountB) {\n        address pair = _pairFor(tokenA, tokenB, stable);\n        {\n            uint value = approveMax ? type(uint).max : liquidity;\n            IPair(pair).permit(\n                msg.sender,\n                address(this),\n                value,\n                deadline,\n                v,\n                r,\n                s\n            );\n        }\n\n        (amountA, amountB) = _removeLiquidity(\n            tokenA,\n            tokenB,\n            stable,\n            liquidity,\n            amountAMin,\n            amountBMin,\n            to,\n            deadline\n        );\n    }\n\n    function removeLiquidityMTRWithPermit(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMTRMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountMTR) {\n        address pair = _pairFor(token, address(wmtr), stable);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountMTR) = _removeLiquidityMTR(\n            token,\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountMTRMin,\n            to,\n            deadline\n        );\n    }\n\n    function removeLiquidityMTRSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountFTMMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountFTM) {\n        return\n            _removeLiquidityMTRSupportingFeeOnTransferTokens(\n                token,\n                stable,\n                liquidity,\n                amountTokenMin,\n                amountFTMMin,\n                to,\n                deadline\n            );\n    }\n\n    function _removeLiquidityMTRSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountFTMMin,\n        address to,\n        uint deadline\n    ) internal ensure(deadline) returns (uint amountToken, uint amountFTM) {\n        (amountToken, amountFTM) = _removeLiquidity(\n            token,\n            address(wmtr),\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountFTMMin,\n            address(this),\n            deadline\n        );\n        IERC20(token).safeTransfer(to, IERC20(token).balanceOf(address(this)));\n        wmtr.withdraw(amountFTM);\n        _safeTransferMTR(to, amountFTM);\n    }\n\n    function removeLiquidityMTRWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountFTMMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountFTM) {\n        address pair = _pairFor(token, address(wmtr), stable);\n        uint value = approveMax ? type(uint).max : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (\n            amountToken,\n            amountFTM\n        ) = _removeLiquidityMTRSupportingFeeOnTransferTokens(\n            token,\n            stable,\n            liquidity,\n            amountTokenMin,\n            amountFTMMin,\n            to,\n            deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        uint[] memory amounts,\n        Route[] memory routes,\n        address _to\n    ) internal virtual {\n        for (uint i = 0; i < routes.length; i++) {\n            (address token0, ) = _sortTokens(routes[i].from, routes[i].to);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = routes[i].from == token0\n                ? (uint(0), amountOut)\n                : (amountOut, uint(0));\n            address to = i < routes.length - 1\n                ? _pairFor(\n                    routes[i + 1].from,\n                    routes[i + 1].to,\n                    routes[i + 1].stable\n                )\n                : _to;\n            IPair(_pairFor(routes[i].from, routes[i].to, routes[i].stable))\n                .swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function _swapSupportingFeeOnTransferTokens(\n        Route[] memory routes,\n        address _to\n    ) internal virtual {\n        for (uint i; i < routes.length; i++) {\n            (address input, address output) = (routes[i].from, routes[i].to);\n            (address token0, ) = _sortTokens(input, output);\n            IPair pair = IPair(\n                _pairFor(routes[i].from, routes[i].to, routes[i].stable)\n            );\n            uint amountInput;\n            uint amountOutput;\n            {\n                // scope to avoid stack too deep errors\n                (uint reserve0, uint reserve1, ) = pair.getReserves();\n                uint reserveInput = input == token0 ? reserve0 : reserve1;\n                amountInput =\n                    IERC20(input).balanceOf(address(pair)) -\n                    reserveInput;\n                //(amountOutput,) = getAmountOut(amountInput, input, output, stable);\n                amountOutput = pair.getAmountOut(amountInput, input);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0\n                ? (uint(0), amountOutput)\n                : (amountOutput, uint(0));\n            address to = i < routes.length - 1\n                ? _pairFor(\n                    routes[i + 1].from,\n                    routes[i + 1].to,\n                    routes[i + 1].stable\n                )\n                : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n\n    function swapExactTokensForTokensSimple(\n        uint amountIn,\n        uint amountOutMin,\n        address tokenFrom,\n        address tokenTo,\n        bool stable,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        Route[] memory routes = new Route[](1);\n        routes[0].from = tokenFrom;\n        routes[0].to = tokenTo;\n        routes[0].stable = stable;\n        amounts = _getAmountsOut(amountIn, routes);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        amounts = _getAmountsOut(amountIn, routes);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactMTRForTokens(\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external payable ensure(deadline) returns (uint[] memory amounts) {\n        require(routes[0].from == address(wmtr), \"VoltRouter: INVALID_PATH\");\n        amounts = _getAmountsOut(msg.value, routes);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        wmtr.deposit{value: amounts[0]}();\n        assert(\n            wmtr.transfer(\n                _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n                amounts[0]\n            )\n        );\n        _swap(amounts, routes, to);\n    }\n\n    function swapExactTokensForMTR(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        require(\n            routes[routes.length - 1].to == address(wmtr),\n            \"VoltRouter: INVALID_PATH\"\n        );\n        amounts = _getAmountsOut(amountIn, routes);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, address(this));\n        wmtr.withdraw(amounts[amounts.length - 1]);\n        _safeTransferMTR(to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) {\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amountIn\n        );\n        uint balanceBefore = IERC20(routes[routes.length - 1].to).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(routes, to);\n        require(\n            IERC20(routes[routes.length - 1].to).balanceOf(to) -\n                balanceBefore >=\n                amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactMTRForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external payable ensure(deadline) {\n        require(routes[0].from == address(wmtr), \"VoltRouter: INVALID_PATH\");\n        uint amountIn = msg.value;\n        wmtr.deposit{value: amountIn}();\n        assert(\n            wmtr.transfer(\n                _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n                amountIn\n            )\n        );\n        uint balanceBefore = IERC20(routes[routes.length - 1].to).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(routes, to);\n        require(\n            IERC20(routes[routes.length - 1].to).balanceOf(to) -\n                balanceBefore >=\n                amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n    }\n\n    function swapExactTokensForMTRSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) {\n        require(\n            routes[routes.length - 1].to == address(wmtr),\n            \"VoltRouter: INVALID_PATH\"\n        );\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(routes, address(this));\n        uint amountOut = IERC20(address(wmtr)).balanceOf(address(this));\n        require(\n            amountOut >= amountOutMin,\n            \"VoltRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        wmtr.withdraw(amountOut);\n        _safeTransferMTR(to, amountOut);\n    }\n\n    function UNSAFE_swapExactTokensForTokens(\n        uint[] memory amounts,\n        Route[] calldata routes,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory) {\n        IERC20(routes[0].from).safeTransferFrom(\n            msg.sender,\n            _pairFor(routes[0].from, routes[0].to, routes[0].stable),\n            amounts[0]\n        );\n        _swap(amounts, routes, to);\n        return amounts;\n    }\n\n    function _safeTransferMTR(address to, uint value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"VoltRouter: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/interface/IWMTR.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IWMTR {\n    function name() external view returns (string memory);\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function symbol() external view returns (string memory);\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n\n    function deposit() external payable;\n\n    function allowance(address, address) external view returns (uint256);\n}\n"
    },
    "contracts/base/core/VoltFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IFactory.sol\";\nimport \"./VoltPair.sol\";\n\ncontract VoltFactory is IFactory {\n    bool public override isPaused;\n    address public pauser;\n    address public pendingPauser;\n    address public override treasury;\n\n    mapping(address => mapping(address => mapping(bool => address)))\n        public\n        override getPair;\n    address[] public allPairs;\n    /// @dev Simplified check if its a pair, given that `stable` flag might not be available in peripherals\n    mapping(address => bool) public override isPair;\n\n    address internal _temp0;\n    address internal _temp1;\n    bool internal _temp;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        bool stable,\n        address pair,\n        uint allPairsLength\n    );\n\n    constructor() {\n        pauser = msg.sender;\n        isPaused = false;\n    }\n\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    function setPauser(address _pauser) external {\n        require(msg.sender == pauser, \"VoltFactory: Not pauser\");\n        pendingPauser = _pauser;\n    }\n\n    function acceptPauser() external {\n        require(msg.sender == pendingPauser, \"VoltFactory: Not pending pauser\");\n        pauser = pendingPauser;\n    }\n\n    function setPause(bool _state) external {\n        require(msg.sender == pauser, \"VoltFactory: Not pauser\");\n        isPaused = _state;\n    }\n\n    function setTreasury(address _treasury) external {\n        require(msg.sender == pauser, \"VoltFactory: Not pauser\");\n        treasury = _treasury;\n    }\n\n    function pairCodeHash() external pure override returns (bytes32) {\n        return keccak256(type(VoltPair).creationCode);\n    }\n\n    function getInitializable()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            bool\n        )\n    {\n        return (_temp0, _temp1, _temp);\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external override returns (address pair) {\n        require(tokenA != tokenB, \"VoltFactory: IDENTICAL_ADDRESSES\");\n        (address token0, address token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"VoltFactory: ZERO_ADDRESS\");\n        require(\n            getPair[token0][token1][stable] == address(0),\n            \"VoltFactory: PAIR_EXISTS\"\n        );\n        // notice salt includes stable as well, 3 parameters\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, stable));\n        (_temp0, _temp1, _temp) = (token0, token1, stable);\n        pair = address(new VoltPair{salt: salt}());\n        getPair[token0][token1][stable] = pair;\n        // populate mapping in the reverse direction\n        getPair[token1][token0][stable] = pair;\n        allPairs.push(pair);\n        isPair[pair] = true;\n        emit PairCreated(token0, token1, stable, pair, allPairs.length);\n    }\n}\n"
    },
    "contracts/base/token/Volt.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"../../interface/IERC20.sol\";\n\ncontract Volt is IERC20 {\n    string public constant symbol = \"VOLT\";\n    string public constant name = \"VoltSwap Governance Token\";\n    uint8 public constant decimals = 18;\n    uint public override totalSupply = 0;\n\n    mapping(address => uint) public override balanceOf;\n    mapping(address => mapping(address => uint)) public override allowance;\n\n    address public minter;\n\n    constructor() {\n        minter = msg.sender;\n        _mint(msg.sender, 0);\n    }\n\n    // No checks as its meant to be once off to set minting rights to Minter\n    function setMinter(address _minter) external {\n        require(msg.sender == minter, \"VOLT: Not minter\");\n        minter = _minter;\n    }\n\n    function approve(address _spender, uint _value)\n        external\n        override\n        returns (bool)\n    {\n        require(_spender != address(0), \"VOLT: Approve to the zero address\");\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function _mint(address _to, uint _amount) internal returns (bool) {\n        require(_to != address(0), \"VOLT: Mint to the zero address\");\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n        emit Transfer(address(0x0), _to, _amount);\n        return true;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint _value\n    ) internal returns (bool) {\n        require(_to != address(0), \"VOLT: Transfer to the zero address\");\n\n        uint fromBalance = balanceOf[_from];\n        require(fromBalance >= _value, \"VOLT: Transfer amount exceeds balance\");\n        unchecked {\n            balanceOf[_from] = fromBalance - _value;\n        }\n\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint _value)\n        external\n        override\n        returns (bool)\n    {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _value\n    ) external override returns (bool) {\n        address spender = msg.sender;\n        uint spenderAllowance = allowance[_from][spender];\n        if (spenderAllowance != type(uint).max) {\n            require(spenderAllowance >= _value, \"VOLT: Insufficient allowance\");\n            unchecked {\n                uint newAllowance = spenderAllowance - _value;\n                allowance[_from][spender] = newAllowance;\n                emit Approval(_from, spender, newAllowance);\n            }\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    function mint(address account, uint amount) external returns (bool) {\n        require(msg.sender == minter, \"VOLT: Not minter\");\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}